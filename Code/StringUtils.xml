<?xml version="1.0" encoding="UTF-8"?>
<RBProject version="2020r2.1" FormatVersion="2" MinIDEVersion="20070100">
<block type="Module" ID="-1122482829">
 <ObjName>StringUtils</ObjName>
 <ObjContainerID>0</ObjContainerID>
 <IsClass>0</IsClass>
 <ItemFlags>1</ItemFlags>
 <IsInterface>0</IsInterface>
 <Compatibility></Compatibility>
 <Method>
  <ItemName>Repeat</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1006299135</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Repeat(s as String, repeatCount as Integer) As String</SourceLine>
   <SourceLine>// Concatenate a string to itself 'repeatCount' times.</SourceLine>
   <SourceLine>// Example: Repeat("spam ", 5) = "spam spam spam spam spam ".</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#pragma disablebackgroundTasks</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if repeatCount &lt;= 0 then return ""</SourceLine>
   <SourceLine>if repeatCount = 1 then return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Implementation note: normally, you don't want to use string concatenation</SourceLine>
   <SourceLine>// for something like this, since that creates a new string on each operation.</SourceLine>
   <SourceLine>// But in this case, we can double the size of the string on iteration, which</SourceLine>
   <SourceLine>// quickly reduces the overhead of concatenation to insignificance.  This method</SourceLine>
   <SourceLine>// is faster than any other we've found (short of declares, which were only</SourceLine>
   <SourceLine>// about 2X faster and were quite platform-specific).</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var desiredLenB As Integer = s.Bytes * repeatCount</SourceLine>
   <SourceLine>Var output as String = s</SourceLine>
   <SourceLine>Var cutoff as Integer = (desiredLenB+1)\2</SourceLine>
   <SourceLine>Var curLenB as Integer = output.Bytes</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>while curLenB &lt; cutoff</SourceLine>
   <SourceLine>output = output + output</SourceLine>
   <SourceLine>curLenB = curLenB + curLenB</SourceLine>
   <SourceLine>wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>output = output + output.LeftBytes( desiredLenB - curLenB) </SourceLine>
   <SourceLine>return output</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s as String, repeatCount as Integer</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>EditDistance</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>29394943</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function EditDistance(s1 As String, s2 As String) As Integer</SourceLine>
   <SourceLine>// Return the Levenshtein distance, aka the edit distance,</SourceLine>
   <SourceLine>// between the two StringUtils.  That's the number of insertions,</SourceLine>
   <SourceLine>// deletions, or changes required to make one string match the other.</SourceLine>
   <SourceLine>// A result of 0 means the strings</SourceLine>
   <SourceLine>// are identical; higher values mean more different.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Note that this function is case-sensitive; if you want a case-</SourceLine>
   <SourceLine>// insensitive measure, simply Uppercase or Lowercase both strings</SourceLine>
   <SourceLine>// before calling.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Implementation adapted from &lt;http://www.merriampark.com/ld.htm&gt;,</SourceLine>
   <SourceLine>// though we're using only a 1D array since the 2D array is wasteful.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#pragma DisableBackgroundTasks</SourceLine>
   <SourceLine>#pragma DisableBoundsChecking</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var n, m As Integer</SourceLine>
   <SourceLine>n = s1.Length</SourceLine>
   <SourceLine>m = s2.Length</SourceLine>
   <SourceLine>if n = 0 then return m</SourceLine>
   <SourceLine>if m = 0 then return n</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var i, j, cost As Integer</SourceLine>
   <SourceLine>Var d(-1) As Integer</SourceLine>
   <SourceLine>ReDim d(m)</SourceLine>
   <SourceLine>for j = 1 to m</SourceLine>
   <SourceLine>d(j) = j</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var s1chars(-1), s2chars(-1) As String</SourceLine>
   <SourceLine>s1chars = s1.split( "" )</SourceLine>
   <SourceLine>s2chars = s2.split( "" )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var s1char As String</SourceLine>
   <SourceLine>Var lastCost, nextCost As Integer</SourceLine>
   <SourceLine>Var a, b, c As Integer</SourceLine>
   <SourceLine>Var jMinus1 As Integer</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for i = 1 to n</SourceLine>
   <SourceLine>s1char = s1chars(i-1)</SourceLine>
   <SourceLine>lastCost = i</SourceLine>
   <SourceLine>jMinus1 = 0</SourceLine>
   <SourceLine>for j = 1 to m</SourceLine>
   <SourceLine>if s1char.compare(s2chars(jMinus1), ComparisonOptions.CaseSensitive ) = 0 then cost = 0 else cost = 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// set nextCost to the minimum of the following three possibilities:</SourceLine>
   <SourceLine>a = d(j) + 1</SourceLine>
   <SourceLine>b = lastCost + 1</SourceLine>
   <SourceLine>c = cost + d(jMinus1)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if a &lt; b then</SourceLine>
   <SourceLine>if c &lt; a then nextCost = c else nextCost = a</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>if c &lt; b then nextCost = c else nextCost = b</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>d(jMinus1) = lastCost</SourceLine>
   <SourceLine>lastCost = nextCost</SourceLine>
   <SourceLine>jMinus1 = j</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>d(m) = lastCost</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return nextCost</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s1 As String, s2 As String</ItemParams>
  <ItemResult>Integer</ItemResult>
 </Method>
 <Method>
  <ItemName>Soundex</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>939010047</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Soundex(s As String, stripPrefix As Boolean = true) As String</SourceLine>
   <SourceLine>// Return the Soundex code for the given string.</SourceLine>
   <SourceLine>// That's the first character, followed by numeric</SourceLine>
   <SourceLine>// codes for the first several consonants.</SourceLine>
   <SourceLine>// For more detail, see: &lt;http://www.searchforancestors.com/soundex.html&gt;</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var prefix, prefixes(-1) As String</SourceLine>
   <SourceLine>Var i, prefixLen As Integer</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>s = s.trim</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if stripPrefix then</SourceLine>
   <SourceLine>prefixes = Array("La ", "De ", "Van ")  // more to come?</SourceLine>
   <SourceLine>for each prefix in prefixes</SourceLine>
   <SourceLine>prefixLen = prefix.Length</SourceLine>
   <SourceLine>if s.left( prefixLen ) = prefix then</SourceLine>
   <SourceLine>s = s.Middle(prefixLen)</SourceLine>
   <SourceLine>exit</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var c, out As String</SourceLine>
   <SourceLine>out = s.left(1).Uppercase</SourceLine>
   <SourceLine>Var sLen, curCode, lastCode As Integer</SourceLine>
   <SourceLine>sLen = s.Length</SourceLine>
   <SourceLine>for i = 2 to sLen</SourceLine>
   <SourceLine>c = s.Middle(i-1, 1).Uppercase</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if str("BPFV").IndexOfBytes(c) &gt; -1  then</SourceLine>
   <SourceLine>curCode = 1</SourceLine>
   <SourceLine>elseif str("CSKGJQXZ").IndexOfBytes(c) &gt; -1 then</SourceLine>
   <SourceLine>curCode = 2</SourceLine>
   <SourceLine>elseif str("DT").IndexOfBytes(c) &gt; -1 then</SourceLine>
   <SourceLine>curCode = 3</SourceLine>
   <SourceLine>elseif c = "L" then</SourceLine>
   <SourceLine>curCode = 4</SourceLine>
   <SourceLine>elseif str("MN").IndexOfBytes(c) &gt; -1 then</SourceLine>
   <SourceLine>curCode = 5</SourceLine>
   <SourceLine>elseif c = "R" then</SourceLine>
   <SourceLine>curCode = 6</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>curCode = 0</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>if curCode &gt; 0 and curCode &lt;&gt; lastCode then</SourceLine>
   <SourceLine>out = out + str(curCode)</SourceLine>
   <SourceLine>if out.length = 4 then return out</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>return str(out + "000").Left(4)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, stripPrefix As Boolean = true</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>Hash</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1394034687</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Hash(s As String) As Integer</SourceLine>
   <SourceLine>// Return the hash value of the given string, as used by Xojo's</SourceLine>
   <SourceLine>// Variant and Dictionary classes.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var v As Variant</SourceLine>
   <SourceLine>v = s</SourceLine>
   <SourceLine>return v.Hash</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String</ItemParams>
  <ItemResult>Integer</ItemResult>
 </Method>
 <Method>
  <ItemName>Count</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>189579263</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Count(source As String, substr As String) As Integer</SourceLine>
   <SourceLine>// Return how many non-overlapping occurrences of 'substr' there</SourceLine>
   <SourceLine>// are in 'source'.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var theCount as Integer</SourceLine>
   <SourceLine>Var substrLength as Integer</SourceLine>
   <SourceLine>Var start as Integer</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>substrLength = substr.length</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if substrLength = 0 then return source.length + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>start = -1</SourceLine>
   <SourceLine>Do</SourceLine>
   <SourceLine>start= source.IndexOf(start, substr )</SourceLine>
   <SourceLine>If start &lt; 0 then return theCount</SourceLine>
   <SourceLine>theCount = theCount + 1</SourceLine>
   <SourceLine>start = start + substrLength</SourceLine>
   <SourceLine>Loop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>source As String, substr As String</ItemParams>
  <ItemResult>Integer</ItemResult>
 </Method>
 <Method>
  <ItemName>CountB</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1360758783</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function CountB(source As String, substr As String) As Integer</SourceLine>
   <SourceLine>// Return how many non-overlapping occurrences of 'substr' there </SourceLine>
   <SourceLine>// are in 'source', doing binary comparison.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var theCount as Integer</SourceLine>
   <SourceLine>Var substrLength as Integer</SourceLine>
   <SourceLine>Var start as Integer</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>substrLength = substr.length</SourceLine>
   <SourceLine>if substrLength = 0 then return source.bytes + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>start = -1</SourceLine>
   <SourceLine>Do</SourceLine>
   <SourceLine>start= source.IndexOfBytes(start, substr)</SourceLine>
   <SourceLine>If start &lt; 0 then return theCount</SourceLine>
   <SourceLine>theCount = theCount + 1</SourceLine>
   <SourceLine>start = start + substrLength</SourceLine>
   <SourceLine>Loop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>source As String, substr As String</ItemParams>
  <ItemResult>Integer</ItemResult>
 </Method>
 <Method>
  <ItemName>PadBoth</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>887015423</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function PadBoth(s as String, width as Integer, padding as String = " ") As String</SourceLine>
   <SourceLine>// Pad a string to at least 'width' characters, by adding padding characters</SourceLine>
   <SourceLine>// to the left and right sides of the string.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// If it is impossible to center the string, the string will be one character</SourceLine>
   <SourceLine>// to the right more than it is to the left.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var length as Integer</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>length = s.Length</SourceLine>
   <SourceLine>if length &gt;= width then return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var mostToRepeat as Integer</SourceLine>
   <SourceLine>mostToRepeat = ceiling((width-length)/padding.Length)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var repeated as String</SourceLine>
   <SourceLine>repeated = Repeat(padding, ceiling(mostToRepeat/2))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return repeated.middle(0, ceiling((width-length)/2)) + s + repeated.middle(0,(width-length)\2)</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s as String, width as Integer, padding as String = " "</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>PadLeft</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>2128388095</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function PadLeft(s as String, width as Integer, padding as String = " ") As String</SourceLine>
   <SourceLine>// Pad a string to at least 'width' characters, by adding padding characters</SourceLine>
   <SourceLine>// to the left side of the string.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var length as Integer</SourceLine>
   <SourceLine>length = s.Length</SourceLine>
   <SourceLine>if length &gt;= width then return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var mostToRepeat as Integer</SourceLine>
   <SourceLine>mostToRepeat = Ceiling((width-length)/padding.length)</SourceLine>
   <SourceLine>return Repeat(padding, mostToRepeat).Middle(0,width-length) + s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s as String, width as Integer, padding as String = " "</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>PadRight</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>961464319</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function PadRight(s as String, width as Integer, padding as String = " ") As String</SourceLine>
   <SourceLine>// Pad a string to at least 'width' characters, by adding padding characters</SourceLine>
   <SourceLine>// to the right side of the string.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var length as Integer</SourceLine>
   <SourceLine>length = s.Length</SourceLine>
   <SourceLine>if length &gt;= width then return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var mostToRepeat as Integer</SourceLine>
   <SourceLine>mostToRepeat = ceiling((width-length)/padding.Length)</SourceLine>
   <SourceLine>return s + Repeat(padding, mostToRepeat).middle(0,width-length)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s as String, width as Integer, padding as String = " "</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>CountFieldsQuoted</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1846396927</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function CountFieldsQuoted(src as string, sep as string) As integer</SourceLine>
   <SourceLine>// Equivalent to Xojo's CountFields() function, but respects quoted values</SourceLine>
   <SourceLine>// Usage: </SourceLine>
   <SourceLine>//    s = """Hello, Kitty"", ""One"", ""Two, Three"""</SourceLine>
   <SourceLine>//    x = CountFieldsQuoted(s, ",")</SourceLine>
   <SourceLine>// result: x=3</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#pragma DisableBoundsChecking</SourceLine>
   <SourceLine>#pragma NilObjectChecking false</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if src.indexOf( sep ) = -1 then return 0</SourceLine>
   <SourceLine>if src.indexOf("""")= -1 then return src.CountFields( sep)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var countParts, i, n, c as integer</SourceLine>
   <SourceLine>Var sepLen as integer = sep.length</SourceLine>
   <SourceLine>Var parts( -1 ) as string</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>parts = src.split( """" )</SourceLine>
   <SourceLine>countParts = parts.LastIndex</SourceLine>
   <SourceLine>for i = 0 to countParts step 2</SourceLine>
   <SourceLine>n = parts( i ).indexOf( sep )</SourceLine>
   <SourceLine>while n &gt; -1</SourceLine>
   <SourceLine>c = c + 1</SourceLine>
   <SourceLine>n = parts(i).IndexOf( n + sepLen,  sep )</SourceLine>
   <SourceLine>wend</SourceLine>
   <SourceLine>next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return c + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>src as string, sep as string</ItemParams>
  <ItemResult>integer</ItemResult>
 </Method>
 <Method>
  <ItemName>NthFieldQuoted</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>702982143</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function NthFieldQuoted(src as string, sep as string, index as integer) As string</SourceLine>
   <SourceLine>// Equivalent to Xojo's nthField() function, but respects quoted values</SourceLine>
   <SourceLine>// Usage: </SourceLine>
   <SourceLine>//    s = """Hello, Kitty"", ""One"", ""Two, Three"""</SourceLine>
   <SourceLine>//    s1 = nthFieldQuoted(s, ",", 3)</SourceLine>
   <SourceLine>// result: s1 = "Two, Three" (including the quotes!)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Easy cases: no occurrences of the separator, or no quotation marks</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if src.IndexOf(sep)=-1 then</SourceLine>
   <SourceLine>if index=1 then</SourceLine>
   <SourceLine>return src</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>return ""</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>elseif src.IndexOf("""")= -1 then</SourceLine>
   <SourceLine>return src.NthField( sep, index)</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Harder case: both separator and quotation marks.</SourceLine>
   <SourceLine>// We'll use InStrQuoted to help us out.</SourceLine>
   <SourceLine>Var sepLen As Integer = sep.Length </SourceLine>
   <SourceLine>Var startPos As Integer = 0</SourceLine>
   <SourceLine>for i As Integer = 1 to index - 1</SourceLine>
   <SourceLine>Var sepPos As Integer = InStrQuoted( startPos, src, sep )</SourceLine>
   <SourceLine>if sepPos = -1 then return ""</SourceLine>
   <SourceLine>startPos = sepPos + sepLen</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>Var sepPos As Integer = InStrQuoted( startPos, src, sep )</SourceLine>
   <SourceLine>if sepPos = -1 then return src.middle(startPos)</SourceLine>
   <SourceLine>return src.Middle( startPos, sepPos - startPos )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Old code is below for posterity.</SourceLine>
   <SourceLine>'Var c, n, startPos, endPos as integer</SourceLine>
   <SourceLine>'Var inQuotes as boolean</SourceLine>
   <SourceLine>'Var a as string</SourceLine>
   <SourceLine>'</SourceLine>
   <SourceLine>'Var sepLen as integer = sep.Len</SourceLine>
   <SourceLine>'Var srcLen as integer = len( src )</SourceLine>
   <SourceLine>'Var leftSep as string = left( sep, 1 )</SourceLine>
   <SourceLine>'Var adjustedIndex as integer = (index -1)</SourceLine>
   <SourceLine>'</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>'endpos = srcLen + 1  // (accounts for final field, where no ending separator is found)</SourceLine>
   <SourceLine>'for n=1 to srcLen</SourceLine>
   <SourceLine>'a = Mid(src,n,1)</SourceLine>
   <SourceLine>'if a= """" then</SourceLine>
   <SourceLine>'inQuotes = not inQuotes</SourceLine>
   <SourceLine>'elseif (a=leftSep) and not inQuotes then</SourceLine>
   <SourceLine>'if mid(src, n, sepLen) = sep then</SourceLine>
   <SourceLine>'c = c + 1</SourceLine>
   <SourceLine>'if index = 1 then</SourceLine>
   <SourceLine>'// First Field</SourceLine>
   <SourceLine>'startPos = 1</SourceLine>
   <SourceLine>'endPos = n-1</SourceLine>
   <SourceLine>'exit</SourceLine>
   <SourceLine>'else</SourceLine>
   <SourceLine>'// Field 2..x</SourceLine>
   <SourceLine>'if (c=adjustedIndex)  then</SourceLine>
   <SourceLine>'// Leading Sep gefunden</SourceLine>
   <SourceLine>'startPos = n+sepLen</SourceLine>
   <SourceLine>'elseif (c = index) then</SourceLine>
   <SourceLine>'// Trailing Sep found</SourceLine>
   <SourceLine>'endPos = n-1</SourceLine>
   <SourceLine>'exit</SourceLine>
   <SourceLine>'end if</SourceLine>
   <SourceLine>'end if</SourceLine>
   <SourceLine>'end if</SourceLine>
   <SourceLine>'end if</SourceLine>
   <SourceLine>'next</SourceLine>
   <SourceLine>'</SourceLine>
   <SourceLine>'if startPos = 0 then</SourceLine>
   <SourceLine>'if index=1 then</SourceLine>
   <SourceLine>'return src</SourceLine>
   <SourceLine>'else</SourceLine>
   <SourceLine>'return ""</SourceLine>
   <SourceLine>'end if</SourceLine>
   <SourceLine>'else</SourceLine>
   <SourceLine>'return mid(src,startPos,endPos-startPos+1)</SourceLine>
   <SourceLine>'end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>src as string, sep as string, index as integer</ItemParams>
  <ItemResult>string</ItemResult>
 </Method>
 <Method>
  <ItemName>Contains</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>2125135871</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Contains(extends s As String, what As String) As Boolean</SourceLine>
   <SourceLine>// Return true if 's' contains the substring 'what'.</SourceLine>
   <SourceLine>// By "contains" we mean case-insensitive, encoding-savvy containment</SourceLine>
   <SourceLine>// as with InStr.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if what = "" then return true</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return s.IndexOf( what ) &gt; -1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>extends s As String, what As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>CountRegEx</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>719642623</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function CountRegEx(s As String, pattern As String) As Integer</SourceLine>
   <SourceLine>// Count the number of occurrences of a RegEx pattern within a string.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var out As Integer</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var re As New RegEx</SourceLine>
   <SourceLine>Var rm As RegExMatch</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>re.SearchPattern = pattern</SourceLine>
   <SourceLine>rm = re.Search( s )</SourceLine>
   <SourceLine>while rm &lt;&gt; nil</SourceLine>
   <SourceLine>'System.DebugLog rm.SubExpressionString(0) + " at " + str(rm.SubExpressionStartB(0)) + " matches " + pattern + " in " + s</SourceLine>
   <SourceLine>out = out + 1</SourceLine>
   <SourceLine>rm = re.Search</SourceLine>
   <SourceLine>wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return out</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, pattern As String</ItemParams>
  <ItemResult>Integer</ItemResult>
 </Method>
 <Method>
  <ItemName>StartsWith</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>296146943</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function StartsWith(extends s As String, withWhat As String) As Boolean</SourceLine>
   <SourceLine>// Return true if 's' starts with the string 'withWhat',</SourceLine>
   <SourceLine>// doing a standard string comparison.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return s.left( withWhat.Length) = withWhat</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>extends s As String, withWhat As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>ContainsB</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1504604159</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ContainsB(extends s As String, what As String) As Boolean</SourceLine>
   <SourceLine>// Return true if 's' contains the substring 'what'.</SourceLine>
   <SourceLine>// By "contains" we mean binary containment</SourceLine>
   <SourceLine>// as with InStrB.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if what = "" then return true</SourceLine>
   <SourceLine>return s.IndexOfBytes( what ) &gt; - 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>extends s As String, what As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>StartsWithB</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>540387327</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function StartsWithB(extends s As String, withWhat As String) As Boolean</SourceLine>
   <SourceLine>// Return true if 's' starts with the string 'withWhat',</SourceLine>
   <SourceLine>// doing a binary comparison.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return s.LeftBytes(withWhat.Length).Compare( withWhat, ComparisonOptions.CaseSensitive ) = 0</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>extends s As String, withWhat As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>IsEmpty</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1478387711</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function IsEmpty(extends s As String) As Boolean</SourceLine>
   <SourceLine>// Return true if the string is empty.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return s = ""</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>extends s As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>InStrReverse</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>821159935</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function InStrReverse(startPos As Integer=-1, source As String, substr As String) As Integer</SourceLine>
   <SourceLine>// Similar to InStr, but searches backwards from the given position</SourceLine>
   <SourceLine>// (or if startPos = -1, then from the end of the string).</SourceLine>
   <SourceLine>// If substr can't be found, returns 0.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var srcLen As Integer = source.Length</SourceLine>
   <SourceLine>if startPos = -1 then startPos = srcLen</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Here's an easy way...</SourceLine>
   <SourceLine>// There may be a faster implementation, but then again, there may not -- it probably</SourceLine>
   <SourceLine>// depends on the particulars of the data.</SourceLine>
   <SourceLine>Var reversedSource As String = Reverse(source)</SourceLine>
   <SourceLine>Var reversedSubstr As String = Reverse(substr)</SourceLine>
   <SourceLine>Var reversedPos As Integer</SourceLine>
   <SourceLine>reversedPos = reversedSource.IndexOf( srcLen - startPos , reversedSubstr )</SourceLine>
   <SourceLine>if reversedPos = -1 then return -1</SourceLine>
   <SourceLine>return srcLen - reversedPos - substr.Length </SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>startPos As Integer=-1, source As String, substr As String</ItemParams>
  <ItemResult>Integer</ItemResult>
 </Method>
 <Method>
  <ItemName>InStrReverseB</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1955551231</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function InStrReverseB(startPosB As Integer=-1, source As String, substr As String) As Integer</SourceLine>
   <SourceLine>// Similar to InStrB, but searches backwards from the given position</SourceLine>
   <SourceLine>// (or if startPosB = -1, then from the end of the string).</SourceLine>
   <SourceLine>// If substr can't be found, returns 0.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var srcLen As Integer = source.Bytes</SourceLine>
   <SourceLine>Var subLen As Integer = substr.Bytes</SourceLine>
   <SourceLine>if startPosB = -1 then startPosB = srcLen</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// We'll do a simple sequential search.  A Boyer-Moore algorithm</SourceLine>
   <SourceLine>// would work better in many cases, but we'd have to rewrite the</SourceLine>
   <SourceLine>// whole algorithm to work backwards.  The sequential search will</SourceLine>
   <SourceLine>// be good enough in most cases anyway.</SourceLine>
   <SourceLine>Var posB As Integer</SourceLine>
   <SourceLine>for posB = Min( srcLen - subLen, startPosB ) downTo 1</SourceLine>
   <SourceLine>if source.MiddleBytes( posB, subLen ).Compare(substr, ComparisonOptions.CaseSensitive ) = 0 then return posB</SourceLine>
   <SourceLine>next posB</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return -1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>startPosB As Integer=-1, source As String, substr As String</ItemParams>
  <ItemResult>Integer</ItemResult>
 </Method>
 <Method>
  <ItemName>SplitToInt</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1363208191</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function SplitToInt(source As String, delimiter As String=" ") As Integer()</SourceLine>
   <SourceLine>// Split a string into fields, then convert each field into an Integer</SourceLine>
   <SourceLine>// using the Val function.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var fields(-1) As String</SourceLine>
   <SourceLine>fields = source.Split(delimiter)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var out(-1) As Integer</SourceLine>
   <SourceLine>ReDim out( fields.LastIndex )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var i As Integer</SourceLine>
   <SourceLine>for i = fields.LastIndex DownTo 0</SourceLine>
   <SourceLine>out(i) = Val( fields(i) )</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return out</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>source As String, delimiter As String=" "</ItemParams>
  <ItemResult>Integer()</ItemResult>
 </Method>
 <Method>
  <ItemName>SplitToVal</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>158429183</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function SplitToVal(source As String, delimiter As String=" ") As Double()</SourceLine>
   <SourceLine>// Split a string into fields, then convert each field into a Double</SourceLine>
   <SourceLine>// using the Val function.  This is appropriate for a set of numbers</SourceLine>
   <SourceLine>// used only by the computer; for human-readable numbers, consider</SourceLine>
   <SourceLine>// using SplitToCDbl instead.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var fields(-1) As String</SourceLine>
   <SourceLine>fields = source.Split(delimiter)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var out(-1) As Double</SourceLine>
   <SourceLine>ReDim out( fields.LastIndex )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var i As Integer</SourceLine>
   <SourceLine>for i = fields.LastIndex DownTo 0</SourceLine>
   <SourceLine>out(i) = Val( fields(i) )</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return out</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>source As String, delimiter As String=" "</ItemParams>
  <ItemResult>Double()</ItemResult>
 </Method>
 <Method>
  <ItemName>SplitToCDbl</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>737347583</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function SplitToCDbl(source As String, delimiter As String=" ") As Double()</SourceLine>
   <SourceLine>// Split a string into fields, then convert each field into a Double</SourceLine>
   <SourceLine>// using the CDbl function.  This is appropriate for a set of numbers</SourceLine>
   <SourceLine>// entered or readable by the end-user.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var fields(-1) As String</SourceLine>
   <SourceLine>fields = source.Split(delimiter)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var out(-1) As Double</SourceLine>
   <SourceLine>ReDim out( fields.LastIndex )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var i As Integer</SourceLine>
   <SourceLine>for i = fields.LastIndex DownTo 0</SourceLine>
   <SourceLine>out(i) = CDbl( fields(i) )</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return out</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>source As String, delimiter As String=" "</ItemParams>
  <ItemResult>Double()</ItemResult>
 </Method>
 <Method>
  <ItemName>SplitByRegEx</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1031503871</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function SplitByRegEx(source As String, delimPattern As String) As String()</SourceLine>
   <SourceLine>// Split a string into fields delimited by a regular expression.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var out(-1) As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var re As New RegEx</SourceLine>
   <SourceLine>Var rm As RegExMatch</SourceLine>
   <SourceLine>Var startPos As Integer</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>re.SearchPattern = delimPattern</SourceLine>
   <SourceLine>rm = re.Search( source )</SourceLine>
   <SourceLine>while rm &lt;&gt; nil</SourceLine>
   <SourceLine>'System.DebugLog rm.SubExpressionString(0) + " at " + str(rm.SubExpressionStartB(0)) + " matches " + pattern + " in " + s</SourceLine>
   <SourceLine>out.Add( source.MiddleBytes( startPos, rm.SubExpressionStartB(0) - startPos ) )</SourceLine>
   <SourceLine>startPos = re.SearchStartPosition</SourceLine>
   <SourceLine>rm = re.Search</SourceLine>
   <SourceLine>wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if startPos &lt; source.Bytes then</SourceLine>
   <SourceLine>out.Add source.MiddleBytes( startPos )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return out</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>source As String, delimPattern As String</ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>SQLify</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1616539647</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function SQLify(s As String) As String</SourceLine>
   <SourceLine>// Return a version of s ready for use in an SQL statement.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// In other words, we just need to double the apostrophes:</SourceLine>
   <SourceLine>return s.ReplaceAll( "'", "''" )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>Chop</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1227892735</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Chop(s As String, charsToCut As Integer) As String</SourceLine>
   <SourceLine>// Return s with the rightmost 'charsToCut' chars removed.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var charsLeft As Integer = s.Length - charsToCut</SourceLine>
   <SourceLine>if charsLeft &lt;= 0 then return ""</SourceLine>
   <SourceLine>return s.Left( s.Length - charsToCut )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, charsToCut As Integer</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>ChopB</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>301352959</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ChopB(s As String, bytesToCut As Integer) As String</SourceLine>
   <SourceLine>// Return s with the rightmost 'bytesToCut' bytes removed.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var bytesLeft As Integer = s.Length - bytesToCut</SourceLine>
   <SourceLine>if bytesLeft &lt;= 0 then return ""</SourceLine>
   <SourceLine>return s.LeftBytes( s.Bytes - bytesToCut )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, bytesToCut As Integer</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>Squeeze</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>2046437375</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Squeeze(s As String, charSet As String=" ") As String</SourceLine>
   <SourceLine>// Find any repeating characters, where the character is a member of</SourceLine>
   <SourceLine>// charSet, and replace the run with a single character.  Note that this</SourceLine>
   <SourceLine>// uses standard RB text matching, and so is case-insensitive; all</SourceLine>
   <SourceLine>// runs will be replaced with the case as given in charSet.  If you need</SourceLine>
   <SourceLine>// case-sensitive squeezing, use SqueezeB.</SourceLine>
   <SourceLine>// Example: Squeeze("woOow mAAAn", "aeiou") = "wow man".</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var sLenB As Integer = s.Bytes</SourceLine>
   <SourceLine>if sLenB &lt; 2 then return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#pragma BackgroundTasks False</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>charSet = ConvertEncoding( charSet, s.Encoding )</SourceLine>
   <SourceLine>for each char as String in charSet.Split( "" )</SourceLine>
   <SourceLine>Var doubleChar As String = char + char</SourceLine>
   <SourceLine>do</SourceLine>
   <SourceLine>s = ReplaceAll( s, doubleChar, char )</SourceLine>
   <SourceLine>Var newLenB As Integer = s.Bytes</SourceLine>
   <SourceLine>if newLenB = sLenB then exit</SourceLine>
   <SourceLine>sLenB = newLenB</SourceLine>
   <SourceLine>loop</SourceLine>
   <SourceLine>next char</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, charSet As String=" "</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>Remove</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1354305535</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Remove(s As String, charSet As String=" ") As String</SourceLine>
   <SourceLine>// Delete all characters which are members of charSet. Example:</SourceLine>
   <SourceLine>// Delete("wooow maaan", "aeiou") = "ww mn".</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var sLenB As Integer = s.Bytes</SourceLine>
   <SourceLine>if sLenB &lt; 2 then return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var m As MemoryBlock</SourceLine>
   <SourceLine>m = New MemoryBlock( sLenB )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>charSet = ConvertEncoding( charSet, s.Encoding )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var sLen As Integer = s.Length</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var char As String</SourceLine>
   <SourceLine>Var spos, mpos As Integer</SourceLine>
   <SourceLine>for spos = 0 to sLen -1</SourceLine>
   <SourceLine>char = s.Middle( spos, 1 )</SourceLine>
   <SourceLine>if charSet.IndexOf(Char) = -1 then</SourceLine>
   <SourceLine>m.StringValue( mpos, char.Bytes ) = char</SourceLine>
   <SourceLine>mpos = mpos + char.bytes</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return DefineEncoding( m.StringValue(0, mpos), s.Encoding )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, charSet As String=" "</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>ReplaceRange</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>500299775</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ReplaceRange(s As String, start As Integer, length As Integer, newText As String) As String</SourceLine>
   <SourceLine>// Replace a part of the given string with a new string.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return s.left( start ) + newText + s.Middle( start + length)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, start As Integer, length As Integer, newText As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>ReplaceRangeB</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1265934335</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ReplaceRangeB(s As String, startB As Integer, lengthB As Integer, newText As String) As String</SourceLine>
   <SourceLine>// Replace a part of the given string with a new string</SourceLine>
   <SourceLine>// (with offset and length in bytes rather than characters).</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return s.LeftBytes(startB) + newText + s.MiddleBytes( startB + lengthB )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, startB As Integer, lengthB As Integer, newText As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>ReverseB</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>2071148543</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ReverseB(s As String) As String</SourceLine>
   <SourceLine>// Return s with the bytes in reverse order.</SourceLine>
   <SourceLine>// Note that if s is text in any encoding that may have</SourceLine>
   <SourceLine>// multi-byte characters, you should probably be using</SourceLine>
   <SourceLine>// Reverse instead of ReverseB.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if s.Bytes &lt; 2 then return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#pragma BackgroundTasks False</SourceLine>
   <SourceLine>Var m as MemoryBlock = s</SourceLine>
   <SourceLine>Var leftIndex as Integer = 0</SourceLine>
   <SourceLine>Var rightIndex as Integer = m.Size - 4</SourceLine>
   <SourceLine>While leftIndex + 4 &lt; rightIndex</SourceLine>
   <SourceLine>Var tempL as Integer = m.Long(leftIndex)</SourceLine>
   <SourceLine>Var tempR as Integer = m.Long(rightIndex)</SourceLine>
   <SourceLine>m.LittleEndian = not m.LittleEndian</SourceLine>
   <SourceLine>m.Long(leftIndex) = tempR</SourceLine>
   <SourceLine>m.Long(rightIndex) =tempL</SourceLine>
   <SourceLine>m.LittleEndian = not m.LittleEndian</SourceLine>
   <SourceLine>leftIndex = leftIndex + 4</SourceLine>
   <SourceLine>rightIndex = rightIndex - 4</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine>rightIndex = rightIndex + 3</SourceLine>
   <SourceLine>While leftIndex &lt; rightIndex</SourceLine>
   <SourceLine>Var temp as Byte = m.Byte(leftIndex)</SourceLine>
   <SourceLine>m.Byte(leftIndex) = m.Byte(rightIndex)</SourceLine>
   <SourceLine>m.Byte(rightIndex) = temp</SourceLine>
   <SourceLine>leftIndex = leftIndex + 1</SourceLine>
   <SourceLine>rightIndex = rightIndex - 1</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine>Return DefineEncoding(m, Encoding(s))</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>EndsWith</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>238155775</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function EndsWith(extends s As String, withWhat As String) As Boolean</SourceLine>
   <SourceLine>// Return true if 's' ends with the string 'withWhat',</SourceLine>
   <SourceLine>// doing a standard string comparison.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return s.right( withWhat.Length) = withWhat</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>extends s As String, withWhat As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>EndsWithB</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1851760639</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function EndsWithB(extends s As String, withWhat As String) As Boolean</SourceLine>
   <SourceLine>// Return true if 's' ends with the string 'withWhat',</SourceLine>
   <SourceLine>// doing a binary comparison.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return s.RightBytes( withWhat.Bytes).Compare( withWhat, ComparisonOptions.CaseSensitive ) = 0</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>extends s As String, withWhat As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>Sprintf</ItemName>
  <Compatibility>TargetHasGUI</Compatibility>
  <Visible>1</Visible>
  <PartID>1981196287</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Sprintf(src as string, ParamArray data as Variant) As string</SourceLine>
   <SourceLine>// Returns a string produced according to the formatting string &lt;src&gt;.</SourceLine>
   <SourceLine>// The format string &lt;src&gt; is composed of zero or more directives: ordinary</SourceLine>
   <SourceLine>// characters (excluding %) that are</SourceLine>
   <SourceLine>// copied directly to the result, and conversion</SourceLine>
   <SourceLine>// specifications, each of which results in fetching its</SourceLine>
   <SourceLine>// own parameter.</SourceLine>
   <SourceLine>// For details, see http://de.php.net/manual/en/function.sprintf.php</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Attention: This function differs from the PHP sprintf() function in that</SourceLine>
   <SourceLine>// it formats floating numbers according to the locale settings.</SourceLine>
   <SourceLine>// For example, in Germany,</SourceLine>
   <SourceLine>//    sprintf("%04.2f", 123.45)</SourceLine>
   <SourceLine>// will return "0123,45".</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Written by Frank Bitterlich, bitterlich@gsco.de</SourceLine>
   <SourceLine>// Additional work by Florent Pillet, florent@florentpillet.com</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// NOTE: This method is currently available only to GUI apps due</SourceLine>
   <SourceLine>// to &lt;http://www.realsoftware.com/feedback/viewreport.php?reportid=owsxeqnf&gt;.</SourceLine>
   <SourceLine>// Once that bug is fixed, we can make this available to console apps too.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var rex as new RegEx</SourceLine>
   <SourceLine>Var match as RegExMatch</SourceLine>
   <SourceLine>Var argtype, padding, alignment, precstr, replacement, frmstr, s as string</SourceLine>
   <SourceLine>Var p, width, precision, index, start, length as integer</SourceLine>
   <SourceLine>Var vf as double</SourceLine>
   <SourceLine>Var datum As Variant</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>rex.SearchPattern = "(%)(0|/s|'.)?(-)?(\d*)(\.\d+)?([%bcdeufosxX])"</SourceLine>
   <SourceLine>rex.Options.Greedy = true</SourceLine>
   <SourceLine>match = rex.Search(src)</SourceLine>
   <SourceLine>index = -1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>do until match = nil</SourceLine>
   <SourceLine>if match.SubExpressionCount = 7 then</SourceLine>
   <SourceLine>Var interim as string = " " + match.SubExpressionString(2)</SourceLine>
   <SourceLine>padding = interim.Right(1)</SourceLine>
   <SourceLine>// if padding = "" then padding = " " // default: space</SourceLine>
   <SourceLine>alignment = match.SubExpressionString(3)</SourceLine>
   <SourceLine>width = Val(match.SubExpressionString(4))</SourceLine>
   <SourceLine>precstr = match.SubExpressionString(5).middle( 2)</SourceLine>
   <SourceLine>precision = Val(precstr)</SourceLine>
   <SourceLine>if precstr="" then precision = 6</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>argtype = match.SubExpressionString(6)</SourceLine>
   <SourceLine>if argtype &lt;&gt; "%" then</SourceLine>
   <SourceLine>index = index + 1</SourceLine>
   <SourceLine>if index &gt; data.LastIndex then</SourceLine>
   <SourceLine>datum = 0</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>datum = data(index)</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>select case argtype</SourceLine>
   <SourceLine>case "%"</SourceLine>
   <SourceLine>replacement = "%"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "b" // binary int</SourceLine>
   <SourceLine>replacement = bin(datum)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "c" // character</SourceLine>
   <SourceLine>replacement = Encodings.UTF8.Chr(datum)</SourceLine>
   <SourceLine>width = 0</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "d" // signed int</SourceLine>
   <SourceLine>if padding = "0" then</SourceLine>
   <SourceLine>frmstr = "-"+Repeat("0", width)</SourceLine>
   <SourceLine>if datum&lt;0 then frmstr = frmstr.Left( frmstr.Length-1) </SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>frmstr = "-#"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>replacement = Format(datum, frmstr)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "e" // scientific notation</SourceLine>
   <SourceLine>vf = datum</SourceLine>
   <SourceLine>frmstr = "-#."+Repeat("0", precision)+"e+"</SourceLine>
   <SourceLine>Replacement = Format(vf, frmstr)</SourceLine>
   <SourceLine>p = Replacement.IndexOf("e")</SourceLine>
   <SourceLine>// Make sure the part after the "e" has two digits</SourceLine>
   <SourceLine>Replacement = Replacement.left(p) + Format(Val(Replacement.middle( p+1)), "+00")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "u" // unsigned int</SourceLine>
   <SourceLine>replacement = Format(datum, "#")</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "f" // signed float</SourceLine>
   <SourceLine>if padding = "0" then</SourceLine>
   <SourceLine>frmstr = "-"+Repeat("0", width)</SourceLine>
   <SourceLine>if datum&lt;0 then frmstr = frmstr.left( frmstr.length-1)</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>frmstr = "-#"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>if precision &gt; 0 then</SourceLine>
   <SourceLine>frmstr = frmstr + "." + Repeat("0", precision)</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>Replacement = Format(datum, frmstr)</SourceLine>
   <SourceLine>if precision &gt; 0 and padding&lt;&gt;"0" then width = width + precision + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "o" // octal int</SourceLine>
   <SourceLine>replacement = Oct(datum)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "s" // string</SourceLine>
   <SourceLine>replacement = datum</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "x" // hex int; uppercase "X" means uppercase hex, "x" is lowercase hex</SourceLine>
   <SourceLine>replacement = hex(datum)</SourceLine>
   <SourceLine>if asc(argtype) = &amp;h58 then // uppercase "X"</SourceLine>
   <SourceLine>replacement = replacement.Uppercase</SourceLine>
   <SourceLine>else // lowercase "x"</SourceLine>
   <SourceLine>replacement = replacement.Lowercase</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end select</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if width&gt;replacement.Length then</SourceLine>
   <SourceLine>if alignment="-" then // align left</SourceLine>
   <SourceLine>replacement=replacement+Repeat(padding, width-replacement.length)</SourceLine>
   <SourceLine>else // align right</SourceLine>
   <SourceLine>replacement=Repeat(padding, width-replacement.length)+replacement</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>start = match.SubExpressionStartB(0)</SourceLine>
   <SourceLine>length = match.SubExpressionString(0).Bytes</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>s = src.LeftBytes( start) + replacement</SourceLine>
   <SourceLine>src = s + src.MiddleBytes(start+length)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>match = rex.Search(src, s.Bytes)</SourceLine>
   <SourceLine>loop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return src</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>src as string, ParamArray data as Variant</ItemParams>
  <ItemResult>string</ItemResult>
 </Method>
 <Method>
  <ItemName>ThousandsSeparator</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>81211391</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ThousandsSeparator() As String</SourceLine>
   <SourceLine>// Return the thousands separator the user uses (either "." or ",").</SourceLine>
   <SourceLine>if mThousandsSeparator = "" then</SourceLine>
   <SourceLine>mThousandsSeparator = Format(1000, "#,#")</SourceLine>
   <SourceLine>mThousandsSeparator = mThousandsSeparator.Middle( 1, 1 )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return mThousandsSeparator</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>DecimalSeparator</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1420707839</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function DecimalSeparator() As String</SourceLine>
   <SourceLine>// Return the decimal separator the user uses (either "." or ",").</SourceLine>
   <SourceLine>if mDecimalSeparator = "" then</SourceLine>
   <SourceLine>mDecimalSeparator = Format(1.2, "0.0")</SourceLine>
   <SourceLine>mDecimalSeparator = mDecimalSeparator.Middle(1, 1)</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return mDecimalSeparator</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>SplitByLength</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>2142566399</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function SplitByLength(s As String, fieldWidth As Integer) As String()</SourceLine>
   <SourceLine>// Split a string into fields, each containing 'fieldWidth' characters</SourceLine>
   <SourceLine>// (except for the last one, which may have fewer).</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if fieldWidth &lt; 1 then   // fieldWidth must be &gt;= 1</SourceLine>
   <SourceLine>raise New OutOfBoundsException</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var out(-1) As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var qty As Integer</SourceLine>
   <SourceLine>qty = Ceiling( s.Length / fieldWidth )</SourceLine>
   <SourceLine>ReDim out( qty - 1 )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var pos, i As Integer</SourceLine>
   <SourceLine>pos = 0</SourceLine>
   <SourceLine>for i = 0 to qty-1</SourceLine>
   <SourceLine>out(i) = s.Middle( pos, fieldWidth )</SourceLine>
   <SourceLine>pos = pos + fieldWidth</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return out</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, fieldWidth As Integer</ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>Trim</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>623605759</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Trim(source As String, charsToTrim As String) As String</SourceLine>
   <SourceLine>// This is an extended version of Xojo's Trim function that lets you specify</SourceLine>
   <SourceLine>// a set of characters to trim.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var srcLen As Integer = source.Length</SourceLine>
   <SourceLine>Var leftPos, i As Integer</SourceLine>
   <SourceLine>for i = 0 to srcLen</SourceLine>
   <SourceLine>if charsToTrim.IndexOf( source.Middle( i, 1) ) = -1 then exit</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>leftPos = i</SourceLine>
   <SourceLine>if leftPos &gt; srcLen then return ""</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var rightPos As Integer</SourceLine>
   <SourceLine>for i = srcLen DownTo 0</SourceLine>
   <SourceLine>if charsToTrim.IndexOf( source.middle( i, 1) ) = -1 then exit</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>rightPos = i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return source.Middle( leftPos, rightPos - leftPos + 1 ) </SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>source As String, charsToTrim As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>SplitByLengthB</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1052512255</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function SplitByLengthB(s As String, fieldWidth As Integer) As String()</SourceLine>
   <SourceLine>// Split a string into fields, each containing 'fieldWidth' bytes</SourceLine>
   <SourceLine>// (except for the last one, which may have fewer).</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if fieldWidth &lt; 1 then   // fieldWidth must be &gt;= 1</SourceLine>
   <SourceLine>raise New OutOfBoundsException</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var out(-1) As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var qty As Integer</SourceLine>
   <SourceLine>qty = Ceiling( s.Bytes / fieldWidth )</SourceLine>
   <SourceLine>ReDim out( qty - 1 )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var pos, i As Integer</SourceLine>
   <SourceLine>pos = 0</SourceLine>
   <SourceLine>for i = 0 to qty-1</SourceLine>
   <SourceLine>out(i) = s.MiddleBytes( pos, fieldWidth )</SourceLine>
   <SourceLine>pos = pos + fieldWidth</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return out</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, fieldWidth As Integer</ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>ControlCharacters</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1776134143</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ControlCharacters() As String</SourceLine>
   <SourceLine>// Return the control character region of the ASCII set,</SourceLine>
   <SourceLine>// i.e., ASCII 0 through 31.</SourceLine>
   <SourceLine>Var i As Integer</SourceLine>
   <SourceLine>if mControlChars = "" then</SourceLine>
   <SourceLine>for i = 0 to 31</SourceLine>
   <SourceLine>mControlChars = mControlChars + Encodings.ASCII.Chr(i)</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return mControlChars</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>LTrim</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>602028031</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function LTrim(source As String, charsToTrim As String) As String</SourceLine>
   <SourceLine>// This is an extended version of Xojo's LTrim function that lets you specify</SourceLine>
   <SourceLine>// a set of characters to trim.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var srcLen As Integer = source.Length</SourceLine>
   <SourceLine>Var leftPos, i As Integer</SourceLine>
   <SourceLine>for i = 0 to srcLen </SourceLine>
   <SourceLine>if charsToTrim.IndexOf( source.Middle( i, 1) ) = -1 then exit</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>leftPos = i </SourceLine>
   <SourceLine>if leftPos &gt; srcLen then return ""</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return source.Middle( leftPos )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>source As String, charsToTrim As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>RTrim</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>607838207</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function RTrim(source As String, charsToTrim As String) As String</SourceLine>
   <SourceLine>// This is an extended version of Xojo's RTrim function that lets you specify</SourceLine>
   <SourceLine>// a set of characters to trim.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var srcLen As Integer = source.Length</SourceLine>
   <SourceLine>Var rightPos, i As Integer</SourceLine>
   <SourceLine>for i = srcLen DownTo 0</SourceLine>
   <SourceLine>if charsToTrim.IndexOf( source.Middle(i, 1) )  = -1 then exit</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>rightPos = i + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return source.Middle( 0, rightPos )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>source As String, charsToTrim As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>HexB</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>2073403391</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function HexB(s As String) As String</SourceLine>
   <SourceLine>// Return a hex representation of each byte of s,</SourceLine>
   <SourceLine>// i.e., each byte becomes a pair of hexadecimal digits,</SourceLine>
   <SourceLine>// separated by spaces from the next byte.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Credit: Charles Yeomans.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if s = "" then return ""</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#if RBVersion &gt; 5.5</SourceLine>
   <SourceLine>Static HexTable as MemoryBlock</SourceLine>
   <SourceLine>#else</SourceLine>
   <SourceLine>Var HexTable as MemoryBlock</SourceLine>
   <SourceLine>#endif</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if HexTable Is Nil then</SourceLine>
   <SourceLine>HexTable = new MemoryBlock(512)</SourceLine>
   <SourceLine>For i as Integer = 0 to 15</SourceLine>
   <SourceLine>HexTable.StringValue(i + i , 2) = "0" + Hex(i)</SourceLine>
   <SourceLine>Next</SourceLine>
   <SourceLine>For i as Integer = 16 to 255</SourceLine>
   <SourceLine>HexTable.StringValue(i + i, 2) = Hex(i)</SourceLine>
   <SourceLine>Next</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var inData as MemoryBlock = new MemoryBlock(s.Bytes)</SourceLine>
   <SourceLine>inData.StringValue(0, inData.Size) = s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var outData as MemoryBlock = new MemoryBlock(3*inData.Size - 1)</SourceLine>
   <SourceLine>outData.Short(0) = HexTable.Short(2*inData.Byte(0))</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var lastByte as Integer = inData.Size - 1</SourceLine>
   <SourceLine>For offset as Integer = 1 to lastByte</SourceLine>
   <SourceLine>outData.Byte(3*offset - 1) = 32 // (space)</SourceLine>
   <SourceLine>outData.Short(3*offset) = HexTable.Short(2*inData.Byte(offset))</SourceLine>
   <SourceLine>Next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return outData.StringValue(0, outData.Size, Encodings.ASCII)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>MatchCase</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1013635071</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function MatchCase(textToChange As String, sampleText As String) As String</SourceLine>
   <SourceLine>// Return a version of textToChange that matches the case style</SourceLine>
   <SourceLine>// of sampleText: Lowercase, Uppercase, or Titlecase.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Examine the text until we find 2 characters that have case.</SourceLine>
   <SourceLine>Var pos As Integer = 1</SourceLine>
   <SourceLine>Var maxPos As Integer = sampleText.Length</SourceLine>
   <SourceLine>Var foundUpper() As Boolean</SourceLine>
   <SourceLine>Var c, upperC, lowerC As String</SourceLine>
   <SourceLine>for pos = 1 to maxPos</SourceLine>
   <SourceLine>c = sampleText.MiddleBytes( pos, 1 )</SourceLine>
   <SourceLine>upperC = c.Uppercase</SourceLine>
   <SourceLine>lowerC = c.Lowercase</SourceLine>
   <SourceLine>if upperC.Compare( lowerC, ComparisonOptions.CaseSensitive ) &lt;&gt; 0 then</SourceLine>
   <SourceLine>// found a character with case; remember which case it is</SourceLine>
   <SourceLine>foundUpper.Add c.compare( upperC, ComparisonOptions.CaseSensitive ) = 0 </SourceLine>
   <SourceLine>if foundUpper.LastIndex  &gt;= 1 then exit</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>// found a caseless character; reset our found list</SourceLine>
   <SourceLine>ReDim foundUpper(-1)</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if foundUpper.LastIndex &lt; 1 then</SourceLine>
   <SourceLine>// didn't find enough characters with case; sample is no good</SourceLine>
   <SourceLine>return textToChange</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if foundUpper(0) then</SourceLine>
   <SourceLine>if foundUpper(1) then return textToChange.Uppercase</SourceLine>
   <SourceLine>return textToChange.Titlecase</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>return textToChange.Lowercase</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine></SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>textToChange As String, sampleText As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>Random</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>139640831</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Random(length As Integer = 8, charset As String = "0123456789ABCDEFGHJKLMNPQRSTUVWXYZ") As String</SourceLine>
   <SourceLine>// Generate a random string of the specified length, by choosing characters</SourceLine>
   <SourceLine>// at random from the given character set.  NOTE: we currently assume that</SourceLine>
   <SourceLine>// all characters in charset are only 1 byte each.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>static m As MemoryBlock</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if m = nil then</SourceLine>
   <SourceLine>m = New MemoryBlock( length )</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>m.Size = length </SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var charsetSize As Integer = charset.length </SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>static r As New Random</SourceLine>
   <SourceLine>for i As Integer = 0 to length - 1</SourceLine>
   <SourceLine>m.StringValue( i, 1 ) = charset.MiddleBytes( r.InRange( 1, charsetSize ), 1 )</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return DefineEncoding( m.StringValue( 0, length ), charset.Encoding )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>length As Integer = 8, charset As String = "0123456789ABCDEFGHJKLMNPQRSTUVWXYZ"</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>SplitQuoted</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1123219455</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function SplitQuoted(source As String, delimiter As String, removeQuotes as Boolean) As String()</SourceLine>
   <SourceLine>// Same as Xojo's Split, except that it respects quoted strings.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var out() As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Easy cases: no occurrences of the separator, or no quotation marks</SourceLine>
   <SourceLine>if source.IndexOf( delimiter ) = -1 then</SourceLine>
   <SourceLine>out = Array( source )</SourceLine>
   <SourceLine>elseif source.IndexOf( """" ) = -1 then</SourceLine>
   <SourceLine>out = source.Split( delimiter )</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>// Harder case: both separator and quotation marks.</SourceLine>
   <SourceLine>// We'll use InStrQuoted to help us out.</SourceLine>
   <SourceLine>Var delimiterLen As Integer = delimiter.Length</SourceLine>
   <SourceLine>Var startPos As Integer = 0</SourceLine>
   <SourceLine>do</SourceLine>
   <SourceLine>Var delimiterPos As Integer = InStrQuoted( startPos, source, delimiter )</SourceLine>
   <SourceLine>if delimiterPos = -1 then</SourceLine>
   <SourceLine>// no more separators</SourceLine>
   <SourceLine>out.Add( source.Middle( startPos ))</SourceLine>
   <SourceLine>exit</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>out.Add( source.Middle( startPos, delimiterPos - startPos ) )</SourceLine>
   <SourceLine>startPos = delimiterPos + delimiterLen</SourceLine>
   <SourceLine>loop</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Finally, strip quotes if asked to do so.</SourceLine>
   <SourceLine>// (Including the case of a start quote without an end quote, which</SourceLine>
   <SourceLine>// could happen in the last field.)</SourceLine>
   <SourceLine>if removeQuotes then</SourceLine>
   <SourceLine>for i As Integer = 0 to out.LastIndex</SourceLine>
   <SourceLine>Var s As String = out(i)</SourceLine>
   <SourceLine>if s.LeftBytes( 1 ) = """" then</SourceLine>
   <SourceLine>if s.RightBytes( 1 ) = """" then</SourceLine>
   <SourceLine>out(i) = s.MiddleBytes( 1, s.Bytes - 2 )</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out(i) = s.MiddleBytes( 1 )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return out</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>source As String, delimiter As String, removeQuotes as Boolean</ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>JoinQuoted</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1349857279</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function JoinQuoted(fields() as String, delimiter as String) As String</SourceLine>
   <SourceLine>// Join the given strings with a delimiter, just like Xojo's intrinsic Join</SourceLine>
   <SourceLine>// method, except that if any of the fields contains the delimiter,</SourceLine>
   <SourceLine>// that item will be surrounded by quotes in the output.  See</SourceLine>
   <SourceLine>// SplitQuoted for the inverse function.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Approach: copy the items into a second array, putting quotes</SourceLine>
   <SourceLine>// around any that contain the delimiter, then Join them.  This</SourceLine>
   <SourceLine>// way we don't mutate the array that's passed in.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var quoted() As String</SourceLine>
   <SourceLine>Var ub As Integer = fields.LastIndex</SourceLine>
   <SourceLine>ReDim quoted( ub )</SourceLine>
   <SourceLine>for i As Integer = 0 to ub</SourceLine>
   <SourceLine>Var fld As String = fields(i)</SourceLine>
   <SourceLine>if fld.IndexOf( Delimiter ) &gt; -1 then</SourceLine>
   <SourceLine>quoted(i) = """" + fld + """"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>quoted(i) = fld</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return string.FromArray( quoted, delimiter )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>fields() as String, delimiter as String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>EncodeCase</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1636495359</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function EncodeCase(s As String) As String</SourceLine>
   <SourceLine>// Return a version of the given string that encodes the uppercase/lowercase state</SourceLine>
   <SourceLine>// of each letter as follows: every time we switch from uppercase to lowercase, we</SourceLine>
   <SourceLine>// insert a "^".  A "^" in the original string will be represented as "^^".  Finally, we</SourceLine>
   <SourceLine>// will assume lowercase at the beginning of the string (so an initial capital letter</SourceLine>
   <SourceLine>// will be preceded by "^").</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// This can be useful for doing things like case-sensitive lookup of strings in a</SourceLine>
   <SourceLine>// Dictionary, which is normally case insensitive.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// For the inverse operation, see DecodeCase.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var chars() As String = s.split( "" )</SourceLine>
   <SourceLine>Var inUpperState As Boolean = false</SourceLine>
   <SourceLine>Var idx As Integer</SourceLine>
   <SourceLine>Var anyUpper As Boolean</SourceLine>
   <SourceLine>for idx = 0 to chars.LastIndex</SourceLine>
   <SourceLine>Var c As String = chars(idx)</SourceLine>
   <SourceLine>if c = "^" then</SourceLine>
   <SourceLine>// got a caret in the original string; double it</SourceLine>
   <SourceLine>chars.addAt( idx, "^")</SourceLine>
   <SourceLine>idx = idx + 1</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>// determine whether the given character fails to match the current state</SourceLine>
   <SourceLine>Var codepoint As Integer = Asc(c)</SourceLine>
   <SourceLine>Var switchCase As Boolean</SourceLine>
   <SourceLine>if inUpperState then</SourceLine>
   <SourceLine>if codepoint &lt; 128 then</SourceLine>
   <SourceLine>// lowercase ASCII ranges from 97 to 122</SourceLine>
   <SourceLine>switchCase = (codepoint &gt;= 97 and codepoint &lt;= 122)</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>// if not ASCII, use Xojo's routines to see if it'd be any different in upper case</SourceLine>
   <SourceLine>switchCase = c.compare( c.Uppercase, ComparisonOptions.CaseSensitive ) &lt;&gt; 0</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>if codepoint &lt; 128 then</SourceLine>
   <SourceLine>// uppercase ASCII ranges from 65 to 90</SourceLine>
   <SourceLine>switchCase = (codepoint &gt;= 65 and codepoint &lt;= 90)</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>// if not ASCII, use Xojo's routines to see if it'd be any different in lower case</SourceLine>
   <SourceLine>switchCase = c.compare(c.Lowercase, ComparisonOptions.CaseSensitive ) &lt;&gt; 0</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>if switchCase then anyUpper = true</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>if switchCase then</SourceLine>
   <SourceLine>// yep, time to switch case</SourceLine>
   <SourceLine>chars.addAt( idx, "^" )</SourceLine>
   <SourceLine>idx = idx + 1</SourceLine>
   <SourceLine>inUpperState = not inUpperState</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var result As String = string.FromArray( chars, "" )</SourceLine>
   <SourceLine>if anyUpper then result = result.Lowercase</SourceLine>
   <SourceLine>return result</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>DecodeCase</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1849563135</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function DecodeCase(s As String) As String</SourceLine>
   <SourceLine>// This function undoes the encoding of case done by EncodeCase, resulting</SourceLine>
   <SourceLine>// in the original string.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var parts() As String = s.split( "^" )</SourceLine>
   <SourceLine>for i As Integer = 1 to parts.lastIndex step 2</SourceLine>
   <SourceLine>if parts(i) = "" then</SourceLine>
   <SourceLine>parts(i) = "^"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>parts(i) = parts(i).Uppercase</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>return string.FromArray(parts, "")</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>Reverse</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1655515135</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Reverse(s As String) As String</SourceLine>
   <SourceLine>// Return s with the characters in reverse order.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if s.length &lt; 2 then return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var characters() as String = s.split( "" )</SourceLine>
   <SourceLine>Var leftIndex as Integer = 0</SourceLine>
   <SourceLine>Var rightIndex as Integer = characters.LastIndex</SourceLine>
   <SourceLine>#pragma BackgroundTasks False</SourceLine>
   <SourceLine>While leftIndex &lt; rightIndex</SourceLine>
   <SourceLine>Var temp as String = characters(leftIndex)</SourceLine>
   <SourceLine>characters(leftIndex) = characters(rightIndex)</SourceLine>
   <SourceLine>characters(rightIndex) = temp</SourceLine>
   <SourceLine>leftIndex = leftIndex + 1</SourceLine>
   <SourceLine>rightIndex = rightIndex - 1</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine>Return string.FromArray( characters, "" )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>LineEnding</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1097977855</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function LineEnding(s As String) As String</SourceLine>
   <SourceLine>// Return the first line ending (of any standard sort: Unix, classic Mac, or Windows)</SourceLine>
   <SourceLine>// which is found in the given string.  If none is found, return standard EndOfLine</SourceLine>
   <SourceLine>// for the platform we're running on.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// The code below can't deal with UTF-16, but should deal fine with anything else.</SourceLine>
   <SourceLine>// So, in those rare cases where we have UTF-16, let's convert.  This could be a</SourceLine>
   <SourceLine>// performance bottleneck if you call this on large UTF-16 strings.</SourceLine>
   <SourceLine>if s.Encoding = Encodings.UTF16 then s = s.ConvertEncoding( Encodings.UTF8 )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Loop over the bytes of the string until we find a 13 or 10.  A line ending should</SourceLine>
   <SourceLine>// be either 13 alone (Mac), 10 alone (Unix), or 13+10 (Windows).</SourceLine>
   <SourceLine>Var posB, maxPosB As Integer</SourceLine>
   <SourceLine>maxPosB = s.Bytes</SourceLine>
   <SourceLine>for posB = 0 to maxPosB</SourceLine>
   <SourceLine>Var b As Integer = s.MiddleBytes( posB, 1 ).AscByte</SourceLine>
   <SourceLine>if b = 10 then</SourceLine>
   <SourceLine>return Chr(10)</SourceLine>
   <SourceLine>elseif b = 13 then</SourceLine>
   <SourceLine>if s.MiddleBytes(posB+1, 1).AscByte = 10 then return Chr(13) + Chr(10)</SourceLine>
   <SourceLine>return Chr(13)</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return EndOfLine</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>InStrQuoted</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1470590975</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function InStrQuoted(start As Integer = 1, source As String, find As String) As Integer</SourceLine>
   <SourceLine>// This is the same as the built-in InStr function, except that it ignores</SourceLine>
   <SourceLine>// any occurrence of "find" within double quotes.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>do</SourceLine>
   <SourceLine>// Find the next occurrence of the search string.  If none, then we're done.</SourceLine>
   <SourceLine>Var foundPos As Integer = source.IndexOf( start, find )</SourceLine>
   <SourceLine>if foundPos = -1 then return foundPos</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Now, also find the next quotation mark; if this comes before</SourceLine>
   <SourceLine>// our foundPos, then we need to ignore that and resume searching</SourceLine>
   <SourceLine>// after the closing quote.  Otherwise, we're done.</SourceLine>
   <SourceLine>Var quotePos As Integer = source.IndexOf( start, """" )</SourceLine>
   <SourceLine>if quotePos = -1 or quotePos &gt; foundPos then return foundPos</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var closeQuotePos As Integer = source.IndexOf(quotePos+1, """" )</SourceLine>
   <SourceLine>if closeQuotePos = -1 then return -1 // no closing quote, treat whole end of string as quoted</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>start = closeQuotePos + 1</SourceLine>
   <SourceLine>loop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>start As Integer = 1, source As String, find As String</ItemParams>
  <ItemResult>Integer</ItemResult>
 </Method>
 <Method>
  <ItemName>Chop</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1649393663</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Chop(s As String, stringToCut As String) As String</SourceLine>
   <SourceLine>// Chops 'stringToCut' off of s, if stringToCut is found at the end.</SourceLine>
   <SourceLine>// Useful for removing file extensions, trailing punctuation, etc.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var cutLen As Integer = stringToCut.Length</SourceLine>
   <SourceLine>if s.right( cutLen) = stringToCut then</SourceLine>
   <SourceLine>return s.Left( s.Length - cutLen )</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>return s</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, stringToCut As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>ChopB</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>382429183</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ChopB(s As String, stringToCut As String) As String</SourceLine>
   <SourceLine>// Chops 'stringToCut' off of s, if stringToCut is found at the end.</SourceLine>
   <SourceLine>// Useful for removing file extensions, trailing punctuation, etc.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var cutLenB As Integer = stringToCut.Bytes</SourceLine>
   <SourceLine>if s.rightBytes(cutLenB).Compare(stringToCut, ComparisonOptions.CaseSensitive ) = 0 then</SourceLine>
   <SourceLine>return s.LeftBytes( s.Bytes - cutLenB )</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>return s</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, stringToCut As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>SqueezeB</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1787234303</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function SqueezeB(s As String, charSet As String=" ") As String</SourceLine>
   <SourceLine>// Find any repeating characters, where the character is a member of</SourceLine>
   <SourceLine>// charSet, and replace the run with a single character.  Note that this</SourceLine>
   <SourceLine>// uses binary matching (and so is case sensitive), but does convert</SourceLine>
   <SourceLine>// charSet into the encoding of s, so you don't have to worry about that.</SourceLine>
   <SourceLine>// Example: Squeeze("wooow maaan", "aeiou") = "wow man".</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var sLenB As Integer = s.Bytes</SourceLine>
   <SourceLine>if sLenB &lt; 2 then return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#pragma BackgroundTasks False</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>charSet = ConvertEncoding( charSet, s.Encoding )</SourceLine>
   <SourceLine>for each char as String in charSet.Split( "" )</SourceLine>
   <SourceLine>Var doubleChar As String = char + char</SourceLine>
   <SourceLine>do</SourceLine>
   <SourceLine>s = s.ReplaceAllBytes( doubleChar, char )</SourceLine>
   <SourceLine>Var newLenB As Integer = s.Bytes</SourceLine>
   <SourceLine>if newLenB = sLenB then exit</SourceLine>
   <SourceLine>sLenB = newLenB</SourceLine>
   <SourceLine>loop</SourceLine>
   <SourceLine>next char</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, charSet As String=" "</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>WrapLines</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>747220991</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub WrapLines(lines() As String, charsPerLine As Integer = 72, paragraphFill As Boolean = true)</SourceLine>
   <SourceLine>// Wrap the text so that no line is longer than charsPerLine.  If paragraphFill</SourceLine>
   <SourceLine>// is true, then whenever one long line is followed by a line that does not</SourceLine>
   <SourceLine>// start with whitespace, join them together into one continuous paragraph.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if lines.LastIndex = -1 then return</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Start by joining lines, if called for.</SourceLine>
   <SourceLine>if paragraphFill then</SourceLine>
   <SourceLine>Var lineNum As Integer = 1</SourceLine>
   <SourceLine>Var lastLineShort As Boolean = ( lines(0).Length &lt; charsPerLine-20 )</SourceLine>
   <SourceLine>while lineNum &lt;= lines.LastIndex</SourceLine>
   <SourceLine>Var line As String = lines( lineNum )</SourceLine>
   <SourceLine>Var firstChar As String = line.left( 1 )</SourceLine>
   <SourceLine>if lastLineShort then</SourceLine>
   <SourceLine>// last line was short, so don't join this one to it</SourceLine>
   <SourceLine>lineNum = lineNum + 1</SourceLine>
   <SourceLine>elseif line = "" or firstChar &lt;= " " or firstChar = "&gt;" or firstChar = "|" then</SourceLine>
   <SourceLine>// this line is empty or starts with whitespace or other special char; don't join it</SourceLine>
   <SourceLine>lineNum = lineNum + 1</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>// this line starts with a character; join it to the previous line</SourceLine>
   <SourceLine>lines( lineNum - 1 ) = lines( lineNum - 1 ) + " " + line</SourceLine>
   <SourceLine>lines.RemoveAt( lineNum )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>lastLineShort = ( line.Length &lt; charsPerLine-20 )</SourceLine>
   <SourceLine>wend</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Then, go through and do the wrapping.</SourceLine>
   <SourceLine>for lineNum As Integer = 0 to lines.LastIndex</SourceLine>
   <SourceLine>Var line As String = lines( lineNum ).TrimRight </SourceLine>
   <SourceLine>if line.Length &lt;= charsPerLine then</SourceLine>
   <SourceLine>lines( lineNum ) = line</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>Var breakPos As Integer</SourceLine>
   <SourceLine>for breakPos = charsPerLine DownTo 1</SourceLine>
   <SourceLine>Var c As String = line.middle( breakPos-1, 1 )</SourceLine>
   <SourceLine>if c &lt;= " " or c = "-" then exit</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>if breakPos &lt; 2 then breakPos = charsPerLine + 1  // no point breaking before char 1</SourceLine>
   <SourceLine>lines.AddAt( lineNum + 1, line.Middle(breakPos-1).TrimLeft )</SourceLine>
   <SourceLine>lines( lineNum ) = line.left(breakPos - 1).TrimLeft</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>lines() As String, charsPerLine As Integer = 72, paragraphFill As Boolean = true</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>GuessEncoding</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1752997887</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function GuessEncoding(s As String) As TextEncoding</SourceLine>
   <SourceLine>// Guess what text encoding the text in the given string is in.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Note that it this version does not report whether the UTF-32 or</SourceLine>
   <SourceLine>// UTF-16 that is in the wrong byte order.  If that's a possibility,</SourceLine>
   <SourceLine>// you should use the other version of GuessEncoding instead.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var whoCares As Boolean</SourceLine>
   <SourceLine>return StringUtils.GuessEncoding( s, whoCares )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String</ItemParams>
  <ItemResult>TextEncoding</ItemResult>
 </Method>
 <Method>
  <ItemName>GuessEncoding</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>429373439</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function GuessEncoding(s As String, ByRef outWrongOrder As Boolean) As TextEncoding</SourceLine>
   <SourceLine>// Guess what text encoding the text in the given string is in.</SourceLine>
   <SourceLine>// This ignores the encoding set on the string, and guesses</SourceLine>
   <SourceLine>// one of the following:</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>//   * UTF-32</SourceLine>
   <SourceLine>//   * UTF-16</SourceLine>
   <SourceLine>//   * UTF-8</SourceLine>
   <SourceLine>//   * Encodings.SystemDefault</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// If the UTF-32 or UTF-16 is in the wrong byte order for this platform,</SourceLine>
   <SourceLine>// then outWrongOrder will be set to true.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>static isBigEndian, endianChecked As Boolean</SourceLine>
   <SourceLine>if not endianChecked then</SourceLine>
   <SourceLine>Var temp As String = Encodings.UTF16.Chr( &amp;hFEFF )</SourceLine>
   <SourceLine>isBigEndian = temp.MiddleBytes(0, 1 ).AscByte = &amp;hFE</SourceLine>
   <SourceLine>endianChecked = true</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// check for a BOM</SourceLine>
   <SourceLine>Var b0 As Integer = s.MiddleBytes( 0, 1 ).AscByte </SourceLine>
   <SourceLine>Var b1 As Integer = s.MiddleBytes( 1, 1 ).AscByte </SourceLine>
   <SourceLine>Var b2 As Integer = s.MiddleBytes( 2, 1 ).AscByte </SourceLine>
   <SourceLine>Var b3 As Integer = s.MiddleBytes( 3, 1 ).AscByte </SourceLine>
   <SourceLine>if b0=0 and b1=0 and b2=&amp;hFE and b3=&amp;hFF then</SourceLine>
   <SourceLine>// UTF-32, big-endian</SourceLine>
   <SourceLine>outWrongOrder = not isBigEndian</SourceLine>
   <SourceLine>return Encodings.UTF32</SourceLine>
   <SourceLine>elseif b0=&amp;hFF and b1=&amp;hFE and b2=0 and b3=0 and s.Length &gt;= 4 then</SourceLine>
   <SourceLine>// UTF-32, little-endian</SourceLine>
   <SourceLine>outWrongOrder = isBigEndian</SourceLine>
   <SourceLine>return Encodings.UTF32</SourceLine>
   <SourceLine>elseif b0=&amp;hFE and b1=&amp;hFF then</SourceLine>
   <SourceLine>// UTF-16, big-endian</SourceLine>
   <SourceLine>outWrongOrder = not isBigEndian</SourceLine>
   <SourceLine>return Encodings.UTF16</SourceLine>
   <SourceLine>elseif b0=&amp;hFF and b1=&amp;hFE then</SourceLine>
   <SourceLine>// UTF-16, little-endian</SourceLine>
   <SourceLine>outWrongOrder = isBigEndian</SourceLine>
   <SourceLine>return Encodings.UTF16</SourceLine>
   <SourceLine>elseif b0=&amp;hEF and b1=&amp;hBB and b1=&amp;hBF then</SourceLine>
   <SourceLine>// UTF-8 (ah, a sensible encoding where endianness doesn't matter!)</SourceLine>
   <SourceLine>return Encodings.UTF8</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// no BOM; see if it's entirely ASCII.</SourceLine>
   <SourceLine>Var m As MemoryBlock = s</SourceLine>
   <SourceLine>Var i, maxi As Integer = s.Bytes - 1</SourceLine>
   <SourceLine>for i = 0 to maxi</SourceLine>
   <SourceLine>if m.Byte(i) &gt; 127 then exit</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>if i &gt; maxi then return Encodings.ASCII</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Not ASCII; check for a high incidence of nulls every other byte,</SourceLine>
   <SourceLine>// which suggests UTF-16 (at least in Roman text).</SourceLine>
   <SourceLine>Var nulls(1) As Integer  // null count in even (0) and odd (1) bytes</SourceLine>
   <SourceLine>for i = 0 to maxi</SourceLine>
   <SourceLine>if m.Byte(i) = 0 then</SourceLine>
   <SourceLine>nulls(i mod 2) = nulls(i mod 2) + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>if nulls(0) &gt; nulls(1)*2 and nulls(0) &gt; maxi\2 then</SourceLine>
   <SourceLine>// UTF-16, big-endian</SourceLine>
   <SourceLine>outWrongOrder = not isBigEndian</SourceLine>
   <SourceLine>return Encodings.UTF16</SourceLine>
   <SourceLine>elseif nulls(1) &gt; nulls(0)*2 and nulls(1) &gt; maxi\2 then</SourceLine>
   <SourceLine>// UTF-16, little-endian</SourceLine>
   <SourceLine>outWrongOrder = isBigEndian</SourceLine>
   <SourceLine>return Encodings.UTF16</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// it's not ASCII; check for illegal UTF-8 characters.</SourceLine>
   <SourceLine>// See Table 3.1B, "Legal UTF-8 Byte Sequences",</SourceLine>
   <SourceLine>// at &lt;http://unicode.org/versions/corrigendum1.html&gt;</SourceLine>
   <SourceLine>Var b As Byte</SourceLine>
   <SourceLine>for i = 0 to maxi</SourceLine>
   <SourceLine>select case m.Byte(i)</SourceLine>
   <SourceLine>case &amp;h00 to &amp;h7F</SourceLine>
   <SourceLine>// single-byte character; just continue</SourceLine>
   <SourceLine>case &amp;hC2 to &amp;hDF</SourceLine>
   <SourceLine>// one additional byte</SourceLine>
   <SourceLine>if i+1 &gt; maxi then exit for</SourceLine>
   <SourceLine>b = m.Byte(i+1)</SourceLine>
   <SourceLine>if b &lt; &amp;h80 or b &gt; &amp;hBF then exit for</SourceLine>
   <SourceLine>i = i+1</SourceLine>
   <SourceLine>case &amp;hE0</SourceLine>
   <SourceLine>// two additional bytes</SourceLine>
   <SourceLine>if i+2 &gt; maxi then exit for</SourceLine>
   <SourceLine>b = m.Byte(i+1)</SourceLine>
   <SourceLine>if b &lt; &amp;hA0 or b &gt; &amp;hBF then exit for</SourceLine>
   <SourceLine>b = m.Byte(i+2)</SourceLine>
   <SourceLine>if b &lt; &amp;h80 or b &gt; &amp;hBF then exit for</SourceLine>
   <SourceLine>i = i+2</SourceLine>
   <SourceLine>case &amp;hE1 to &amp;hEF</SourceLine>
   <SourceLine>// two additional bytes</SourceLine>
   <SourceLine>if i+2 &gt; maxi then exit for</SourceLine>
   <SourceLine>b = m.Byte(i+1)</SourceLine>
   <SourceLine>if b &lt; &amp;h80 or b &gt; &amp;hBF then exit for</SourceLine>
   <SourceLine>b = m.Byte(i+2)</SourceLine>
   <SourceLine>if b &lt; &amp;h80 or b &gt; &amp;hBF then exit for</SourceLine>
   <SourceLine>i = i+2</SourceLine>
   <SourceLine>case &amp;hF0</SourceLine>
   <SourceLine>// three additional bytes</SourceLine>
   <SourceLine>if i+3 &gt; maxi then exit for</SourceLine>
   <SourceLine>b = m.Byte(i+1)</SourceLine>
   <SourceLine>if b &lt; &amp;h90 or b &gt; &amp;hBF then exit for</SourceLine>
   <SourceLine>b = m.Byte(i+2)</SourceLine>
   <SourceLine>if b &lt; &amp;h80 or b &gt; &amp;hBF then exit for</SourceLine>
   <SourceLine>b = m.Byte(i+3)</SourceLine>
   <SourceLine>if b &lt; &amp;h80 or b &gt; &amp;hBF then exit for</SourceLine>
   <SourceLine>i = i+3</SourceLine>
   <SourceLine>case &amp;hF1 to &amp;hF3</SourceLine>
   <SourceLine>// three additional bytes</SourceLine>
   <SourceLine>if i+3 &gt; maxi then exit for</SourceLine>
   <SourceLine>b = m.Byte(i+1)</SourceLine>
   <SourceLine>if b &lt; &amp;h80 or b &gt; &amp;hBF then exit for</SourceLine>
   <SourceLine>b = m.Byte(i+2)</SourceLine>
   <SourceLine>if b &lt; &amp;h80 or b &gt; &amp;hBF then exit for</SourceLine>
   <SourceLine>b = m.Byte(i+3)</SourceLine>
   <SourceLine>if b &lt; &amp;h80 or b &gt; &amp;hBF then exit for</SourceLine>
   <SourceLine>i = i+3</SourceLine>
   <SourceLine>case &amp;hF4</SourceLine>
   <SourceLine>// three additional bytes</SourceLine>
   <SourceLine>if i+3 &gt; maxi then exit for</SourceLine>
   <SourceLine>b = m.Byte(i+1)</SourceLine>
   <SourceLine>if b &lt; &amp;h80 or b &gt; &amp;h8F then exit for</SourceLine>
   <SourceLine>b = m.Byte(i+2)</SourceLine>
   <SourceLine>if b &lt; &amp;h80 or b &gt; &amp;hBF then exit for</SourceLine>
   <SourceLine>b = m.Byte(i+3)</SourceLine>
   <SourceLine>if b &lt; &amp;h80 or b &gt; &amp;hBF then exit for</SourceLine>
   <SourceLine>i = i+3</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>exit for</SourceLine>
   <SourceLine>end select</SourceLine>
   <SourceLine>next i</SourceLine>
   <SourceLine>if i &gt; maxi then return Encodings.UTF8  // no illegal UTF-8 sequences, so that's probably what it is</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// If not valid UTF-8, then let's just guess the system default.</SourceLine>
   <SourceLine>return Encodings.SystemDefault</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String, ByRef outWrongOrder As Boolean</ItemParams>
  <ItemResult>TextEncoding</ItemResult>
 </Method>
 <Method>
  <ItemName>SwapBytePairs</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>794681343</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function SwapBytePairs(s As String) As String</SourceLine>
   <SourceLine>// Swap every pair of bytes in the given string.  This can be useful</SourceLine>
   <SourceLine>// when dealing with UTF-16 data with the wrong byte order.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var inm As MemoryBlock = s</SourceLine>
   <SourceLine>inm.LittleEndian = true</SourceLine>
   <SourceLine>Var outm As New MemoryBlock( inm.Size )</SourceLine>
   <SourceLine>outm.LittleEndian = false</SourceLine>
   <SourceLine>Var maxi As Integer = inm.Size - 2</SourceLine>
   <SourceLine>for i As Integer = 0 to maxi step 2</SourceLine>
   <SourceLine>outm.UInt16Value(i) = inm.UInt16Value(i)</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>return outm.StringValue( 0, outm.Size, s.Encoding )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>SwapByteQuads</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1101479935</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function SwapByteQuads(s As String) As String</SourceLine>
   <SourceLine>// Swap the order of every 4 bytes in the given string.  This can be useful</SourceLine>
   <SourceLine>// when dealing with UTF-32 data with the wrong byte order.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Var inm As MemoryBlock = s</SourceLine>
   <SourceLine>inm.LittleEndian = true</SourceLine>
   <SourceLine>Var outm As New MemoryBlock( inm.Size )</SourceLine>
   <SourceLine>outm.LittleEndian = false</SourceLine>
   <SourceLine>Var maxi As Integer = inm.Size - 4</SourceLine>
   <SourceLine>for i As Integer = 0 to maxi step 4</SourceLine>
   <SourceLine>outm.UInt32Value(i) = inm.UInt32Value(i)</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>return outm.StringValue( 0, outm.Size, s.Encoding )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>Metaphone</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1779681279</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Metaphone(source As String, ByRef outPrimary As String, ByRef outAlternate As String)</SourceLine>
   <SourceLine>// Compute the Double Metaphone of the source string.  This is an algorithm that</SourceLine>
   <SourceLine>// finds one or two approximate phonetic representations of a string, useful in</SourceLine>
   <SourceLine>// searching for almost-matches -- e.g., looking for names whose spelling may have</SourceLine>
   <SourceLine>// varied, or correcting typos made by the user, and so on.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// The output is roughly human-readable, with the following conventions:</SourceLine>
   <SourceLine>//   Vowels are omitted from the output, except for a vowel at the beginning</SourceLine>
   <SourceLine>//      of a word, which is represented by an A (e.g. "ox" becomes "AKS")</SourceLine>
   <SourceLine>//   X is used to represent a "ch" sound (e.g., "church" becomes "XRX")</SourceLine>
   <SourceLine>//   0 (zero) is used to represent a "th" sound (e.g. "think" becomes "0NK")</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// For more information about Double Metaphone, see:</SourceLine>
   <SourceLine>//     http://aspell.sourceforge.net/metaphone/</SourceLine>
   <SourceLine>//     http://www.cuj.com/articles/2000/0006/0006d/0006d.htm?topic=articles</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// This implementation is based on the one at:</SourceLine>
   <SourceLine>//     http://aspell.sourceforge.net/metaphone/dmetaph.cpp</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim length As Integer</SourceLine>
   <SourceLine>length = source.Length</SourceLine>
   <SourceLine>if length &lt; 1 then</SourceLine>
   <SourceLine>outPrimary = ""</SourceLine>
   <SourceLine>outAlternate = ""</SourceLine>
   <SourceLine>return</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>source = source.Uppercase + " "</SourceLine>
   <SourceLine>Dim current As Integer = 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim charAt(-1) As String</SourceLine>
   <SourceLine>charAt = source.Split("")</SourceLine>
   <SourceLine>charAt.AddAt( 0, "" )  // (make it 1-based, like Mid)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim slavoGermanic As Boolean</SourceLine>
   <SourceLine>if str("W").IndexOf( source ) &gt; -1 or str("K").IndexOf( source ) &gt; -1 _</SourceLine>
   <SourceLine>or str("CZ").IndexOf( source ) &gt; -1 or str("WITZ").IndexOf( source ) &gt; -1 then</SourceLine>
   <SourceLine>slavoGermanic = true</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim out1, out2 As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// skip these when at start of word</SourceLine>
   <SourceLine>if MStringAt(source, 1, 2, "GN", "KN", "PN", "WR", "PS") then current = current + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// initial 'X' is pronounced 'Z' e.g. 'Xavier'</SourceLine>
   <SourceLine>if charAt(1) = "X" then</SourceLine>
   <SourceLine>out1 = out1 + "S"  </SourceLine>
   <SourceLine>out2 = out2 + "S"  // "Z" maps to "S"</SourceLine>
   <SourceLine>current = current + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//---------- main loop ---------------</SourceLine>
   <SourceLine>while current &lt;= length</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>select case charAt(current)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "A", "E", "I", "O", "U", "Y"</SourceLine>
   <SourceLine>if current = 1 then</SourceLine>
   <SourceLine>// all initial vowels map to "A"; elsewhere they're skipped</SourceLine>
   <SourceLine>out1 = out1 + "A"  </SourceLine>
   <SourceLine>out2 = out2 + "A"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>current = current + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "B"</SourceLine>
   <SourceLine>//"-mb", e.g", "dumb", already skipped over...</SourceLine>
   <SourceLine>out1 = out1 + "P"  </SourceLine>
   <SourceLine>out2 = out2 + "P"</SourceLine>
   <SourceLine>if charAt(current + 1) = "B" then</SourceLine>
   <SourceLine>current = current + 2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case ""</SourceLine>
   <SourceLine>out1 = out1 + "S"  </SourceLine>
   <SourceLine>out2 = out2 + "S"</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "C"</SourceLine>
   <SourceLine>// various germanic</SourceLine>
   <SourceLine>if current &gt; 2 _</SourceLine>
   <SourceLine>and not MIsVowel(source, current - 2) _</SourceLine>
   <SourceLine>and MStringAt(source, (current - 1), 3, "ACH") _ </SourceLine>
   <SourceLine>and (charAt(current + 2) &lt;&gt; "I" and (charAt(current + 2) &lt;&gt; "E"_</SourceLine>
   <SourceLine>or MStringAt(source, current - 2, 6, "BACHER", "MACHER")) ) then       </SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>current = current + 2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif current = 1 AND MStringAt(source, current, 6, "CAESAR") then</SourceLine>
   <SourceLine>// special case 'caesar' (why didn't this go at the top?)</SourceLine>
   <SourceLine>out1 = out1 + "S"  </SourceLine>
   <SourceLine>out2 = out2 + "S"</SourceLine>
   <SourceLine>current = current + 2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current, 4, "CHIA") then</SourceLine>
   <SourceLine>// italian 'chianti'</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>current = current + 2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current, 2, "CH") then       </SourceLine>
   <SourceLine>// find 'michael'</SourceLine>
   <SourceLine>if current &gt; 0 AND MStringAt(source, current, 4, "CHAE") then</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "X"</SourceLine>
   <SourceLine>current = current + 2</SourceLine>
   <SourceLine>break</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif current = 0 _</SourceLine>
   <SourceLine>and (MStringAt(source, current + 1, 5, "HARAC", "HARIS") _</SourceLine>
   <SourceLine>or MStringAt(source, current + 1, 3, "HOR", "HYM", "HIA", "HEM")) _</SourceLine>
   <SourceLine>and not MStringAt(source, 0, 5, "CHORE") then</SourceLine>
   <SourceLine>// greek roots e.g. 'chemistry', 'chorus'</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>current = current + 2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>//germanic, greek, or otherwise 'ch' for 'kh' sound</SourceLine>
   <SourceLine>if((MStringAt(source, 0, 4, "VAN ", "VON ") or MStringAt(source, 0, 3, "SCH")) _</SourceLine>
   <SourceLine>_ // 'architect but not 'arch', 'orchestra', 'orchid'</SourceLine>
   <SourceLine>or MStringAt(source, current - 2, 6, "ORCHES", "ARCHIT", "ORCHID") _</SourceLine>
   <SourceLine>or MStringAt(source, current + 2, 1, "T", "S") _</SourceLine>
   <SourceLine>or ((MStringAt(source, current - 1, 1, "A", "O", "U", "E") OR current = 1) _</SourceLine>
   <SourceLine>_ //e.g., 'wachtler', 'wechsler', but not 'tichner'</SourceLine>
   <SourceLine>and MStringAt(source, current + 2, 1, "L", "R", "N", "M", "B", "H", "F", "V", "W", " "))) then</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>else  </SourceLine>
   <SourceLine>if current &gt; 1 then</SourceLine>
   <SourceLine>if MStringAt(source, 1, 2, "MC") then</SourceLine>
   <SourceLine>//e.g., "McHugh"</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "X"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "X"  </SourceLine>
   <SourceLine>out2 = out2 + "X"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>current = current + 2</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// end of CH case</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current, 2, "CZ") and not MStringAt(source, current - 2, 4, "WICZ") then</SourceLine>
   <SourceLine>//e.g, 'czerny'</SourceLine>
   <SourceLine>out1 = out1 + "S"  </SourceLine>
   <SourceLine>out2 = out2 + "X"</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current + 1, 3, "CIA") then</SourceLine>
   <SourceLine>//e.g., 'focaccia'</SourceLine>
   <SourceLine>out1 = out1 + "X"  </SourceLine>
   <SourceLine>out2 = out2 + "X"</SourceLine>
   <SourceLine>current = current +  3</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current, 2, "CC") and not (current = 2 AND charAt(1) = "M") then</SourceLine>
   <SourceLine>// double "C", but not if e.g. 'McClellan'</SourceLine>
   <SourceLine>//'bellocchio' but not 'bacchus'</SourceLine>
   <SourceLine>if MStringAt(source, current + 2, 1, "I", "E", "H") and not MStringAt(source, current + 2, 2, "HU") then</SourceLine>
   <SourceLine>//'accident', 'accede" "succeed'</SourceLine>
   <SourceLine>if((current = 2 AND charAt(current - 1) = "A") _</SourceLine>
   <SourceLine>OR MStringAt(source, current - 1, 5, "UCCEE", "UCCES")) then</SourceLine>
   <SourceLine>out1 = out1 + "KS"  </SourceLine>
   <SourceLine>out2 = out2 + "KS"</SourceLine>
   <SourceLine>//'bacci', 'bertucci', other italian</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "X"  </SourceLine>
   <SourceLine>out2 = out2 + "X"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>current = current +  3</SourceLine>
   <SourceLine>else // Pierce's rule</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current, 2, "CK", "CG", "CQ") then</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current, 2, "CI", "CE", "CY") then</SourceLine>
   <SourceLine>// italian vs. english</SourceLine>
   <SourceLine>if MStringAt(source, current, 3, "CIO", "CIE", "CIA") then</SourceLine>
   <SourceLine>out1 = out1 + "S"  </SourceLine>
   <SourceLine>out2 = out2 + "X"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "S"  </SourceLine>
   <SourceLine>out2 = out2 + "S"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>// all other C cases are considered a K:</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// name sent in 'mac caffrey', 'mac gregor'</SourceLine>
   <SourceLine>if MStringAt(source, current + 1, 2, " C", " Q", " G" ) then</SourceLine>
   <SourceLine>current = current +  3</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>if MStringAt(source, current + 1, 1, "C", "K", "Q") _</SourceLine>
   <SourceLine>AND not MStringAt(source, current + 1, 2, "CE", "CI") then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "D"</SourceLine>
   <SourceLine>if MStringAt(source, current, 2, "DG") then</SourceLine>
   <SourceLine>if MStringAt(source, current + 2, 1, "I", "E", "Y") then</SourceLine>
   <SourceLine>//e.g. 'edge'</SourceLine>
   <SourceLine>out1 = out1 + "J"  </SourceLine>
   <SourceLine>out2 = out2 + "J"</SourceLine>
   <SourceLine>current = current +  3</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>//e.g. 'edgar'</SourceLine>
   <SourceLine>out1 = out1 + "TK"  </SourceLine>
   <SourceLine>out2 = out2 + "TK"</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current, 2, "DT", "DD") then</SourceLine>
   <SourceLine>out1 = out1 + "T"  </SourceLine>
   <SourceLine>out2 = out2 + "T"</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "T"  </SourceLine>
   <SourceLine>out2 = out2 + "T"</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "F"</SourceLine>
   <SourceLine>out1 = out1 + "F"  </SourceLine>
   <SourceLine>out2 = out2 + "F"</SourceLine>
   <SourceLine>if charAt(current + 1) = "F" then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "G"</SourceLine>
   <SourceLine>if charAt(current + 1) = "H"  then</SourceLine>
   <SourceLine>// GH...</SourceLine>
   <SourceLine>if current &gt; 1 AND not MIsVowel(source, current - 1) then</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif current = 1 then</SourceLine>
   <SourceLine>//'ghislane', ghiradelli</SourceLine>
   <SourceLine>if charAt(current + 2) = "I" then</SourceLine>
   <SourceLine>out1 = out1 + "J"  </SourceLine>
   <SourceLine>out2 = out2 + "J"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif((current &gt; 2 AND MStringAt(source, current - 2, 1, "B", "H", "D") ) _</SourceLine>
   <SourceLine>_ //e.g., 'bough'</SourceLine>
   <SourceLine>OR (current &gt; 3 AND MStringAt(source, current - 3, 1, "B", "H", "D") ) _</SourceLine>
   <SourceLine>_ //e.g., 'broughton'</SourceLine>
   <SourceLine>OR (current &gt; 4 AND MStringAt(source, current - 4, 1, "B", "H") ) ) then</SourceLine>
   <SourceLine>//Parker's rule (with some further refinements) - e.g., 'hugh'</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>//e.g., 'laugh', 'McLaughlin', 'cough', 'gough', 'rough', 'tough'</SourceLine>
   <SourceLine>if current &gt; 3 _</SourceLine>
   <SourceLine>AND charAt(current - 1) = "U" _</SourceLine>
   <SourceLine>AND MStringAt(source, current - 3, 1, "C", "G", "L", "R", "T") then</SourceLine>
   <SourceLine>out1 = out1 + "F"  </SourceLine>
   <SourceLine>out2 = out2 + "F"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>if((current &gt; 0) AND charAt(current - 1) &lt;&gt; "I") then</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif charAt(current + 1) = "N" then</SourceLine>
   <SourceLine>// GN...</SourceLine>
   <SourceLine>if current = 1 AND MIsVowel(source, 0) AND not SlavoGermanic then</SourceLine>
   <SourceLine>out1 = out1 + "KN"  </SourceLine>
   <SourceLine>out2 = out2 + "N"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>//not e.g. 'cagney'</SourceLine>
   <SourceLine>if not MStringAt(source, current + 2, 2, "EY") _</SourceLine>
   <SourceLine>AND charAt(current + 1) &lt;&gt; "Y" AND not SlavoGermanic then</SourceLine>
   <SourceLine>out1 = out1 + "N"  </SourceLine>
   <SourceLine>out2 = out2 + "KN"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "KN"  </SourceLine>
   <SourceLine>out2 = out2 + "KN"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current + 1, 2, "LI") AND not SlavoGermanic then</SourceLine>
   <SourceLine>//'tagliaro'</SourceLine>
   <SourceLine>out1 = out1 + "KL"  </SourceLine>
   <SourceLine>out2 = out2 + "L"</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif current = 1 _</SourceLine>
   <SourceLine>AND (charAt(current + 1) = "Y"  _</SourceLine>
   <SourceLine>OR MStringAt(source, current + 1, 2, "ES", "EP", "EB", "EL", "EY", "IB", "IL", "IN", "IE", "EI", "ER")) then</SourceLine>
   <SourceLine>//ges-,gep-,gel-, gie- at beginning</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "J"</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif (MStringAt(source, current + 1, 2, "ER") OR charAt(current + 1) = "Y") _</SourceLine>
   <SourceLine>AND not MStringAt(source, 1, 6, "DANGER", "RANGER", "MANGER") _</SourceLine>
   <SourceLine>AND not MStringAt(source, current - 1, 1, "E", "I") _</SourceLine>
   <SourceLine>AND not MStringAt(source, current - 1, 3, "RGY", "OGY") then</SourceLine>
   <SourceLine>// -ger-,  -gy-</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "J"</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current + 1, 1, "E", "I", "Y") OR MStringAt(source, current - 1, 4, "AGGI", "OGGI") then</SourceLine>
   <SourceLine>// italian e.g, 'biaggi'</SourceLine>
   <SourceLine>//obvious germanic</SourceLine>
   <SourceLine>if MStringAt(source, 1, 4, "VAN ", "VON ") OR MStringAt(source, 1, 3, "SCH") _</SourceLine>
   <SourceLine>OR MStringAt(source, current + 1, 2, "ET") then</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>//always soft if french ending</SourceLine>
   <SourceLine>if MStringAt(source, current + 1, 4, "IER ") then</SourceLine>
   <SourceLine>out1 = out1 + "J"  </SourceLine>
   <SourceLine>out2 = out2 + "J"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "J"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>// any other G</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>if charAt(current + 1) = "G" then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "H"</SourceLine>
   <SourceLine>//only keep if first &amp; before vowel or btw. 2 vowels</SourceLine>
   <SourceLine>if (current = 1 OR MIsVowel(source, current - 1)) AND MIsVowel(source, current + 1) then</SourceLine>
   <SourceLine>out1 = out1 + "H"  </SourceLine>
   <SourceLine>out2 = out2 + "H"</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else//also takes care of 'HH'</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "J"</SourceLine>
   <SourceLine>//obvious spanish, 'jose', 'san jacinto'</SourceLine>
   <SourceLine>if MStringAt(source, current, 4, "JOSE") OR MStringAt(source, 1, 4, "SAN ") then</SourceLine>
   <SourceLine>if (current = 0 AND charAt(current + 4) = " ") OR MStringAt(source, 1, 4, "SAN ") then</SourceLine>
   <SourceLine>out1 = out1 + "H"  </SourceLine>
   <SourceLine>out2 = out2 + "H"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "J"  </SourceLine>
   <SourceLine>out2 = out2 + "H"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>current = current + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>if current = 0 AND not MStringAt(source, current, 4, "JOSE") then</SourceLine>
   <SourceLine>out1 = out1 + "J"  </SourceLine>
   <SourceLine>out2 = out2 + "A"//Yankelovich/Jankelowicz</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>//spanish pron. of e.g. 'bajador'</SourceLine>
   <SourceLine>if MIsVowel(source, current - 1) _</SourceLine>
   <SourceLine>AND not SlavoGermanic _</SourceLine>
   <SourceLine>AND (charAt(current + 1) = "A" OR charAt(current + 1) = "O") then</SourceLine>
   <SourceLine>out1 = out1 + "J"  </SourceLine>
   <SourceLine>out2 = out2 + "H"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>if current = length then</SourceLine>
   <SourceLine>out1 = out1 + "J"  </SourceLine>
   <SourceLine>out2 = out2 + ""</SourceLine>
   <SourceLine>elseif not MStringAt(source, current + 1, 1, "L", "T", "K", "S", "N", "M", "B", "Z") _</SourceLine>
   <SourceLine>AND not MStringAt(source, current - 1, 1, "S", "K", "L") then</SourceLine>
   <SourceLine>out1 = out1 + "J"  </SourceLine>
   <SourceLine>out2 = out2 + "J"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if charAt(current + 1) = "J" then //it could happen! </SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "K"</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>if charAt(current + 1) = "K" then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "L"</SourceLine>
   <SourceLine>if charAt(current + 1) = "L" then</SourceLine>
   <SourceLine>//spanish e.g. 'cabrillo', 'gallegos'</SourceLine>
   <SourceLine>if (current = length - 2 AND MStringAt(source, current - 1, 4, "ILLO", "ILLA", "ALLE")) _</SourceLine>
   <SourceLine>OR ((MStringAt(source, length - 1, 2, "AS", "OS") OR MStringAt(source, length, 1, "A", "O")) _</SourceLine>
   <SourceLine>AND MStringAt(source, current - 1, 4, "ALLE")) then</SourceLine>
   <SourceLine>out1 = out1 + "L"  </SourceLine>
   <SourceLine>out2 = out2 + ""</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "L"  </SourceLine>
   <SourceLine>out2 = out2 + "L"</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "L"  </SourceLine>
   <SourceLine>out2 = out2 + "L"</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "M"</SourceLine>
   <SourceLine>out1 = out1 + "M"  </SourceLine>
   <SourceLine>out2 = out2 + "M"</SourceLine>
   <SourceLine>if (MStringAt(source, current - 1, 3, "UMB") _ </SourceLine>
   <SourceLine>AND (current + 1 = length OR MStringAt(source, current + 2, 2, "ER"))) _</SourceLine>
   <SourceLine>_ //'dumb","thumb'</SourceLine>
   <SourceLine>OR charAt(current + 1) = "M" then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "N"</SourceLine>
   <SourceLine>out1 = out1 + "N"  </SourceLine>
   <SourceLine>out2 = out2 + "N"</SourceLine>
   <SourceLine>if charAt(current + 1) = "N" then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case ""</SourceLine>
   <SourceLine>out1 = out1 + "N"  </SourceLine>
   <SourceLine>out2 = out2 + "N"</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "P"</SourceLine>
   <SourceLine>if charAt(current + 1) = "H" then  // PH sounds like F</SourceLine>
   <SourceLine>out1 = out1 + "F"  </SourceLine>
   <SourceLine>out2 = out2 + "F"</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "P"  </SourceLine>
   <SourceLine>out2 = out2 + "P"</SourceLine>
   <SourceLine>// (also account for "campbell", "raspberry")</SourceLine>
   <SourceLine>if MStringAt(source, current + 1, 1, "P", "B") then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "Q"</SourceLine>
   <SourceLine>out1 = out1 + "K"  </SourceLine>
   <SourceLine>out2 = out2 + "K"</SourceLine>
   <SourceLine>if charAt(current + 1) = "Q" then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "R"</SourceLine>
   <SourceLine>//french e.g. 'rogier', but exclude 'hochmeier'</SourceLine>
   <SourceLine>if current = length AND not SlavoGermanic _</SourceLine>
   <SourceLine>AND MStringAt(source, current - 2, 2, "IE") _ </SourceLine>
   <SourceLine>AND not MStringAt(source, current - 4, 2, "ME", "MA") then</SourceLine>
   <SourceLine>out1 = out1 + ""  </SourceLine>
   <SourceLine>out2 = out2 + "R"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "R"  </SourceLine>
   <SourceLine>out2 = out2 + "R"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if charAt(current + 1) = "R" then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "S"</SourceLine>
   <SourceLine>if MStringAt(source, current - 1, 3, "ISL", "YSL") then</SourceLine>
   <SourceLine>//special cases 'island', 'isle', 'carlisle', 'carlysle'</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif current = 1 AND MStringAt(source, current, 5, "SUGAR") then</SourceLine>
   <SourceLine>//special case 'sugar-'</SourceLine>
   <SourceLine>out1 = out1 + "X"  </SourceLine>
   <SourceLine>out2 = out2 + "S"</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current, 2, "SH") then</SourceLine>
   <SourceLine>//germanic</SourceLine>
   <SourceLine>if MStringAt(source, current + 1, 4, "HEIM", "HOEK", "HOLM", "HOLZ") then</SourceLine>
   <SourceLine>out1 = out1 + "S"  </SourceLine>
   <SourceLine>out2 = out2 + "S"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "X"  </SourceLine>
   <SourceLine>out2 = out2 + "X"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current, 3, "SIO", "SIA") OR MStringAt(source, current, 4, "SIAN") then</SourceLine>
   <SourceLine>//italian &amp; armenian</SourceLine>
   <SourceLine>if not SlavoGermanic then</SourceLine>
   <SourceLine>out1 = out1 + "S"  </SourceLine>
   <SourceLine>out2 = out2 + "X"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "S"  </SourceLine>
   <SourceLine>out2 = out2 + "S"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>current = current +  3</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif (current = 1 AND MStringAt(source, current + 1, 1, "M", "N", "L", "W")) _</SourceLine>
   <SourceLine>OR MStringAt(source, current + 1, 1, "Z") then</SourceLine>
   <SourceLine>//german &amp; anglicisations, e.g. 'smith' match 'schmidt', 'snider' match 'schneider'</SourceLine>
   <SourceLine>//also, -sz- in slavic language altho in hungarian it is pronounced "s"</SourceLine>
   <SourceLine>out1 = out1 + "S"  </SourceLine>
   <SourceLine>out2 = out2 + "X"</SourceLine>
   <SourceLine>if MStringAt(source, current + 1, 1, "Z") then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current, 2, "SC") then</SourceLine>
   <SourceLine>//Schlesinger's rule</SourceLine>
   <SourceLine>if charAt(current + 2) = "H" then</SourceLine>
   <SourceLine>//dutch origin, e.g. 'school', 'schooner'</SourceLine>
   <SourceLine>if MStringAt(source, current + 3, 2, "OO", "ER", "EN", "UY", "ED", "EM") then</SourceLine>
   <SourceLine>//'schermerhorn', 'schenker'</SourceLine>
   <SourceLine>if MStringAt(source, current + 3, 2, "ER", "EN") then</SourceLine>
   <SourceLine>out1 = out1 + "X"  </SourceLine>
   <SourceLine>out2 = out2 + "SK"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "SK"  </SourceLine>
   <SourceLine>out2 = out2 + "SK"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>current = current +  3</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>if current = 1 AND not MIsVowel(source, 4) AND charAt(4) &lt;&gt; "W" then</SourceLine>
   <SourceLine>out1 = out1 + "X"  </SourceLine>
   <SourceLine>out2 = out2 + "S"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "X"  </SourceLine>
   <SourceLine>out2 = out2 + "X"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>current = current +  3</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current + 2, 1, "I", "E", "Y") then</SourceLine>
   <SourceLine>out1 = out1 + "S"  </SourceLine>
   <SourceLine>out2 = out2 + "S"</SourceLine>
   <SourceLine>current = current +  3</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "SK"  </SourceLine>
   <SourceLine>out2 = out2 + "SK"</SourceLine>
   <SourceLine>current = current +  3</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>//french e.g. 'resnais', 'artois'</SourceLine>
   <SourceLine>if current = length AND MStringAt(source, current - 2, 2, "AI", "OI") then</SourceLine>
   <SourceLine>out1 = out1 + ""  </SourceLine>
   <SourceLine>out2 = out2 + "S"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "S"  </SourceLine>
   <SourceLine>out2 = out2 + "S"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>if MStringAt(source, current + 1, 1, "S", "Z") then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "T"</SourceLine>
   <SourceLine>if MStringAt(source, current, 4, "TION") then</SourceLine>
   <SourceLine>out1 = out1 + "X"  </SourceLine>
   <SourceLine>out2 = out2 + "X"</SourceLine>
   <SourceLine>current = current +  3</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current, 3, "TIA", "TCH") then</SourceLine>
   <SourceLine>out1 = out1 + "X"  </SourceLine>
   <SourceLine>out2 = out2 + "X"</SourceLine>
   <SourceLine>current = current +  3</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current, 2, "TH") OR MStringAt(source, current, 3, "TTH") then</SourceLine>
   <SourceLine>//special case 'thomas', 'thames' or germanic</SourceLine>
   <SourceLine>if MStringAt(source, current + 2, 2, "OM", "AM") _</SourceLine>
   <SourceLine>OR MStringAt(source, 1, 4, "VAN ", "VON ") OR MStringAt(source, 1, 3, "SCH") then</SourceLine>
   <SourceLine>out1 = out1 + "T"  </SourceLine>
   <SourceLine>out2 = out2 + "T"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "0"     // 0 represents "TH" sound in Metaphone</SourceLine>
   <SourceLine>out2 = out2 + "T"     // (a bad choice -- # would have been better)</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "T"  </SourceLine>
   <SourceLine>out2 = out2 + "T"</SourceLine>
   <SourceLine>if MStringAt(source, current + 1, 1, "T", "D") then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "V"</SourceLine>
   <SourceLine>out1 = out1 + "F"  </SourceLine>
   <SourceLine>out2 = out2 + "F"</SourceLine>
   <SourceLine>if charAt(current + 1) = "V" then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "W"</SourceLine>
   <SourceLine>//can also be in middle of word</SourceLine>
   <SourceLine>if MStringAt(source, current, 2, "WR") then</SourceLine>
   <SourceLine>out1 = out1 + "R"  </SourceLine>
   <SourceLine>out2 = out2 + "R"</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>if current = 1 AND (MIsVowel(source, current + 1) OR MStringAt(source, current, 2, "WH")) then</SourceLine>
   <SourceLine>//Wasserman should match Vasserman</SourceLine>
   <SourceLine>if(MIsVowel(source, current + 1)) then</SourceLine>
   <SourceLine>out1 = out1 + "A"  </SourceLine>
   <SourceLine>out2 = out2 + "F"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>//need Uomo to match Womo</SourceLine>
   <SourceLine>out1 = out1 + "A"  </SourceLine>
   <SourceLine>out2 = out2 + "A"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if (current = length AND MIsVowel(source, current - 1)) _</SourceLine>
   <SourceLine>OR MStringAt(source, current - 1, 5, "EWSKI", "EWSKY", "OWSKI", "OWSKY") _</SourceLine>
   <SourceLine>OR MStringAt(source, 1, 3, "SCH") then</SourceLine>
   <SourceLine>//Arnow should match Arnoff</SourceLine>
   <SourceLine>out1 = out1 + ""  </SourceLine>
   <SourceLine>out2 = out2 + "F"</SourceLine>
   <SourceLine>current = current + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif MStringAt(source, current, 4, "WICZ", "WITZ") then</SourceLine>
   <SourceLine>//polish e.g. 'filipowicz'</SourceLine>
   <SourceLine>out1 = out1 + "TS"  </SourceLine>
   <SourceLine>out2 = out2 + "FX"</SourceLine>
   <SourceLine>current = current + 4</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>//else skip it</SourceLine>
   <SourceLine>current = current + 1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "X"</SourceLine>
   <SourceLine>//french e.g. breaux</SourceLine>
   <SourceLine>if not (current = length AND _</SourceLine>
   <SourceLine>(MStringAt(source, current - 3, 3, "IAU", "EAU") OR MStringAt(source, current - 2, 2, "AU", "OU"))) then</SourceLine>
   <SourceLine>out1 = out1 + "KS"  </SourceLine>
   <SourceLine>out2 = out2 + "KS"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if MStringAt(source, current + 1, 1, "C", "X") then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>case "Z"</SourceLine>
   <SourceLine>//chinese pinyin e.g. 'zhao'</SourceLine>
   <SourceLine>if charAt(current + 1) = "H" then</SourceLine>
   <SourceLine>out1 = out1 + "J"  </SourceLine>
   <SourceLine>out2 = out2 + "J"</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>if MStringAt(source, current + 1, 2, "ZO", "ZI", "ZA") _</SourceLine>
   <SourceLine>OR (SlavoGermanic AND current &gt; 1 AND charAt(current - 1) &lt;&gt; "T") then</SourceLine>
   <SourceLine>out1 = out1 + "S"  </SourceLine>
   <SourceLine>out2 = out2 + "TS"</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>out1 = out1 + "S"  </SourceLine>
   <SourceLine>out2 = out2 + "S"</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if charAt(current + 1) = "Z" then</SourceLine>
   <SourceLine>current = current +  2</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>current = current +  1</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// ----</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>// if none of the above cases, just skip this character</SourceLine>
   <SourceLine>current = current + 1</SourceLine>
   <SourceLine>end Select</SourceLine>
   <SourceLine>wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>outPrimary = out1</SourceLine>
   <SourceLine>outAlternate = out2</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>1</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>source As String, ByRef outPrimary As String, ByRef outAlternate As String</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>MStringAt</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1874302975</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function MStringAt(source As String, start As Integer, length As Integer, ParamArray args As String) As Boolean</SourceLine>
   <SourceLine>// This is a private helper function for the Metaphone method.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if start &lt; 1 then return false</SourceLine>
   <SourceLine>Dim target As String</SourceLine>
   <SourceLine>if start &gt; source.Length then</SourceLine>
   <SourceLine>target = " "</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>target = source.Middle( start-1, length )</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>return (args.IndexOf(target) &gt;= 0)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>source As String, start As Integer, length As Integer, ParamArray args As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>MisVowel</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>168368127</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function MisVowel(source As String, atPos As Integer) As Boolean</SourceLine>
   <SourceLine>// This is a private helper function for the Metaphone method.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return str("AEIOUY").IndexOf( source.Middle(atPos-1, 1) ) &gt; -1</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>source As String, atPos As Integer</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Note>
  <ItemName>Contributors</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1193558015</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <NoteLine>Contributors</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>Many people have contributed to the development of this module, including:</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>Frank Bitterlich, bitterlich@gsco.de</NoteLine>
   <NoteLine>Ben Blake, benb@kagi.com</NoteLine>
   <NoteLine>Cortis Clark, cortis@realsoftware.com</NoteLine>
   <NoteLine>Carlos Martinho, rblists@rbtips.com</NoteLine>
   <NoteLine>Jeannot Muller, dr@jeannot-muller.com (*)</NoteLine>
   <NoteLine>Jon Johnson, jonj@realsoftware.com</NoteLine>
   <NoteLine>Joe Strout, joe@strout.net </NoteLine>
   <NoteLine>Florent Pillet, florent@florentpillet.com</NoteLine>
   <NoteLine>Kem Tekinay, ktekinay@mactechnologies.com</NoteLine>
   <NoteLine>Charles Yeomans, yeomans@desuetude.com</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>(*) To whom correspondence should be addressed.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine></NoteLine>
  </ItemSource>
  <ItemFlags>1</ItemFlags>
 </Note>
 <Note>
  <ItemName>Home Page</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1567500287</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <NoteLine>Home Page</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>This StringUtils module in the API Version 2 is maintained by TECcompanion GmbH.</NoteLine>
   <NoteLine>The current administrative contact for it is Jeannot Muller (jeannot-muller.com).</NoteLine>
   <NoteLine>You should be able to find the latest version via this URL:</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>    https://jeannot-muller.com/ and on GitHub: https://github.com/Jeannot-Muller/Xojo-StringUtilsHarness-API2</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine></NoteLine>
  </ItemSource>
  <ItemFlags>1</ItemFlags>
 </Note>
 <Note>
  <ItemName>Version History</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>1669410815</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <NoteLine>Version History</NoteLine>
   <NoteLine>2004-JUL-17: version 1.0</NoteLine>
   <NoteLine>- First public release.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>2004-JUL-22: version 1.1</NoteLine>
   <NoteLine>- Fixed some (harmless) warnings in CountRegEx and Repeat.</NoteLine>
   <NoteLine>- Added ControlCharacters.</NoteLine>
   <NoteLine>- Added DecimalSeparator.</NoteLine>
   <NoteLine>- Added ThousandsSeparator.</NoteLine>
   <NoteLine>- Added SplitByLength and SplitByLengthB.</NoteLine>
   <NoteLine>- Added Sprintf.</NoteLine>
   <NoteLine>- Added Trim, LTrim, and RTrim (with charsToTrim parameter).</NoteLine>
   <NoteLine>- Improved the speed of CountFieldsQuoted substantially.</NoteLine>
   <NoteLine>- Improved the speed of NthFieldQuoted and Squeeze slightly.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>2004-SEP-23: version 1.2</NoteLine>
   <NoteLine>- Fixed a bug in the TestSplitToVal unit test.</NoteLine>
   <NoteLine>- Fixed a bug in EditDistance causing incorrect results in some cases.</NoteLine>
   <NoteLine>- Improved the speed of EditDistance substantially.</NoteLine>
   <NoteLine>- Changed EditDistance to be case-sensitive.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>2005-AUG-05: version 1.3</NoteLine>
   <NoteLine>- Improved speed of InStrReverseB.</NoteLine>
   <NoteLine>- Fixed a bug in Sprintf that caused incorrect results when non-ASCII</NoteLine>
   <NoteLine>  characters were used in the format string.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>2006-MAR-13: version 1.4</NoteLine>
   <NoteLine>- Improved speed of HexB slightly.</NoteLine>
   <NoteLine>- Added MatchCase function.</NoteLine>
   <NoteLine>- Fixed a bug in NthFieldQuoted which would cause it to fail when </NoteLine>
   <NoteLine>   the separator occurred as the first character of the string.</NoteLine>
   <NoteLine>- Added Random function.</NoteLine>
   <NoteLine>- Made all functions available to console apps except Sprintf.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>2006-APR-10: version 1.5</NoteLine>
   <NoteLine>- Improved speed of HexB substantially.</NoteLine>
   <NoteLine>- Adjusted Random so that it should work in 5.5 and earlier (untested).</NoteLine>
   <NoteLine>- Added SplitQuoted and JoinQuoted functions.</NoteLine>
   <NoteLine>- Added EncodeCase and DecodeCase functions.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>2006-JUN-29: version 1.6</NoteLine>
   <NoteLine>- Fixed buggy handling of "%%" in Sprintf, and made it so that unspecified</NoteLine>
   <NoteLine>   values are output as if you had specified 0; also changed %c to output</NoteLine>
   <NoteLine>   a Unicode character for the given code point.</NoteLine>
   <NoteLine>- Improved speed of Reverse and ReverseB (thanks to Charles Yeomans).</NoteLine>
   <NoteLine>   Note that I'm not sure whether the new code works in 5.5; somebody who</NoteLine>
   <NoteLine>   has 5.5 is going to have to start helping with that (if anyone cares).</NoteLine>
   <NoteLine>- Added new LineEnding function, that returns the first line ending (of</NoteLine>
   <NoteLine>   any standard sort) that is found in the string.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>2006-AUG-08: version 1.7</NoteLine>
   <NoteLine>- Added InStrQuoted function.</NoteLine>
   <NoteLine>- Rewrote SplitQuoted in terms of InStrQuoted.  This fixed several bugs</NoteLine>
   <NoteLine>   in the previous implementation, including an infinite loop and an</NoteLine>
   <NoteLine>   OutOfBoundsException that could occur on certain inputs.</NoteLine>
   <NoteLine>- Rewrote NthFieldQuoted in terms of InStrQuoted, just to make the code</NoteLine>
   <NoteLine>   simpler and more consistent.  This should cause no changes in behavior.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>2006-SEP-06: version 1.8</NoteLine>
   <NoteLine>- Fixed a bug in EndsWithB that would cause it to fail on multi-byte characters.</NoteLine>
   <NoteLine>- Added versions of Chop and ChopB that specify a string to chop off, rather</NoteLine>
   <NoteLine>   than a number of characters.</NoteLine>
   <NoteLine>- Dramatically improved the speed of Squeeze.  NOTE: Also changed the</NoteLine>
   <NoteLine>   behavior slightly.  Squeeze now uses standard, non-binary text matching.</NoteLine>
   <NoteLine>- A new function, SqueezeB, is now provided for binary squeezing.  Both</NoteLine>
   <NoteLine>   versions are substantially faster than the old one, which always did binary,</NoteLine>
   <NoteLine>   but existing code may want to switch to SqueezeB.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>2007-MAR-15: version 1.9</NoteLine>
   <NoteLine>- Made Chop and ChopB work in RB2006R4 as they did in previous versions,</NoteLine>
   <NoteLine>  returning an empty string when told to chop more than the total number</NoteLine>
   <NoteLine>  of chars or bytes.  (Previous code relied on an undefined behavior of Left</NoteLine>
   <NoteLine>  and LeftB.)</NoteLine>
   <NoteLine>- Added the WrapLines function.</NoteLine>
   <NoteLine>- Improved speed of the Repeat function, especially on large repeat counts.</NoteLine>
   <NoteLine>- Added the GuessEncoding functions.</NoteLine>
   <NoteLine>- Added the SwapBytePairs and SwapByteQuads functions.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>2012-AUG-10: version 2.0</NoteLine>
   <NoteLine>- Fixed a bug in Sprintf that caused incorrect results in some cases when the</NoteLine>
   <NoteLine>  replacement values contained non-ASCII characters.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>2020-DEC-26: version 2.1</NoteLine>
   <NoteLine>- First public release.</NoteLine>
   <NoteLine>- Conversion to Xojo API2</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>2020-DEC-27: version 2.2</NoteLine>
   <NoteLine>- Added API1 and API2 versions as a binaryfile to the repository.</NoteLine>
   <NoteLine></NoteLine>
  </ItemSource>
  <ItemFlags>1</ItemFlags>
 </Note>
 <Note>
  <ItemName>License</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>244283391</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <NoteLine>License</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>This StringUtils module is in the public domain.  You may use it for any purpose</NoteLine>
   <NoteLine>whatsoever, but it comes with no express or implied warranty of correctness or</NoteLine>
   <NoteLine>fitness for any purpose.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>Share and enjoy!</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine></NoteLine>
  </ItemSource>
  <ItemFlags>1</ItemFlags>
 </Note>
 <Property>
  <ItemName>mThousandsSeparator</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>647110655</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>mThousandsSeparator As String</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>mThousandsSeparator As String</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>mDecimalSeparator</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>856870911</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>mDecimalSeparator As String</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>mDecimalSeparator As String</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>mControlChars</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <PartID>2136872959</PartID>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>mControlChars As String</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>mControlChars As String</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <ViewBehavior>
  <ViewProperty>
   <ObjName>Name</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <ItemType>String</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Index</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <PropertyValue>-2147483648</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Super</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <ItemType>String</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Left</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>Position</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Top</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>Position</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
 </ViewBehavior>
</block>
</RBProject>
